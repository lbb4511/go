{"./":{"url":"./","title":"Go语言资料","keywords":"","body":"视频 郝林-Go语言第一课 Go编程基础 Go Web 基础 Go名库讲解 社区 官网要翻墙北京服务器 https://github.com/golang/ https://go-zh.org/ Go语言中文社区 Go语言中文网博客 Golang中国 Go 技术社区 Go语言中国社区 Google网上论坛Golang-China 谷歌官方项目列表博客 傅小黑的自留地 铁哥's blog_【golang周报】 精彩博文 七牛首席布道师：Go不是在颠覆，就是在逆袭 GO语言学习资源整理 GO 语言学习的五个阶段（带例子） 英文原文 Go 语言简介（下）— 特性 Golang汇编快速指南 Go Web 编程 Go 入门指南 (《The Way to Go》中文版) Go 官方文档翻译 Go 指南 (《A Tour of Go》中文版) Go 简易教程 (《 The Little Go Book 》中文版) Go 编程基础 Go 语言实战笔记 Go 语言标准库 Go命令教程 Go实战开发 Go语言博客实践 Java程序员的Golang入门指南 Network programming with Go 中文翻译版本 Revel 框架手册 学习Go语言 神奇的 Go 语言 基础教程 易百 菜鸟教程 Go by Example图书 谢孟军的《Go Web 编程》 郝林的《GO 命令教程》 郝林的《Go并发编程实战》 雨痕的《go 语言学习笔记》 看云Golang图书 《Go语言圣经（中文版）》 Effective Go中文版 无闻Unknwon等翻译Go入门指南 神奇的 Go 语言 学习 GO 语言 Go系统编程 工具 Go Walker - Go 语言在线 API 文档 Golang项目列表在线IDE Fenby的Google Go语言 A Tour of Go（Go语言编程指南）有中文版但是不能在线编译 项目列表 看过awesome-go项目， 汇总了很多go开源项目。 但是awesome-go收集了太全了， 而且每个项目没有详细描述。 因此我自己根据go语言中文社区提供的资料，还有互联网企业架构设计中的常见组件分类， 共精心挑选了100多个开源项目（项目不限于在github开源的项目）， 分成以下十几个大类。 这个项目可以理解为互联网IT人打造的中文版awesome-go。这个项目初衷是帮助到那些想学习和借鉴优秀golang开源项目， 和在互联网架构设计时期望快速寻找合适轮子的人。 监控系统 项目 简介 OpenFalcon OpenFalcon是一款小米开源的监控系统。功能：数据采集免配置：agent自发现、支持Plugin、主动推送模式; 容量水平扩展：生产环境每秒50万次数据收集、告警、存储、绘图，可持续水平扩展。告警策略自发现：Web界面、支持策略模板、模板继承和覆盖、多种告警方式、支持回调动作。告警设置人性化：支持最大告警次数、告警级别设置、告警恢复通知、告警暂停、不同时段不同阈值、支持维护周期，支持告警合并。历史数据高效查询：秒级返回上百个指标一年的历史数据。Dashboard人性化：多维度的数据展示，用户自定义Dashboard等功能。架构设计高可用：整个系统无核心单点，易运维，易部署。 banshee 周期性指标的监控系统. Kapacitor Kapacitor 是一个开源框架，用来处理、监控和警告时间序列数据。 Pome Pome 是 Postgres Metrics 的意思。Pome 是一个 PostgreSQL 的指标仪表器，用来跟踪你的数据库的健康状况。 pingd pingd 是世界上最简单的监控服务，使用 golang 编写。软件支持 IPv6，但是服务器不支持. pingd 允许同时 ping 上千个 IPs，在此期间还可以管理监控的主机。用户提供主机名或者 IP，还有用户邮箱地址，就可以使用 3 个生成 URLs 来开启，停止或者删除你的追踪。每当你的服务器停机或者后台在线都会发送通知，还包含控制 URLs。 actiontech zabbix mysql monitor percona monitoring plugins zabbix 的 Go 语言版本，是由 爱可生 公司开源的 MySQL 监控插件和模板，整合上百个性能监控指标，支持Low Level Discovery 自动发现多实例环境，支持performance_schema rtop top 是一个简单的无代理的远程服务器监控工具，基于 SSH 连接进行工作。无需在被监控的服务器上安装任何软件。rtop 直接通过 SSH 连接到待监控服务器，然后执行命令来收集监控数据。rtop 每几秒钟就自动更新监控数据，类似其他 *top 命令 Prometheus Prometheus 是一个开源的服务监控系统和时间序列数据库， 提供监控数据存储，展示，告警等功能 bosun 专业的跨平台开源系统监控项目，go语言编写，灵活的模板和表达式配合上各种collector可以监控任何应用或系统级的运行数据，比 zabbix更轻量级、更易入手和更适合定制。 urlooker 监控web服务可用性及访问质量，采用go语言编写，易于安装和二次开发. 支持一下特性： 返回状态码检测; 页面响应时间检测; 页面关键词匹配检测; 带cookie访问; agent多机房部署，指定机房访问; 检测结果支持向open-falcon推送; 支持短信和邮件告警 satellite 用于监测kubernetes健康状态的一个工具／库。 其特点是：轻量级定期测试， 高可用性和弹性网络分区， 无单点故障， 以时间序列的格式存储监控数据。 checkup 一个分布式的无锁的站点健康状态检查工具。 支持检查http， tcp， dns等的状态 并可将结果保存在s3。 自带了一个美观的界面。 zabbixctl Zabbixctl 是采用Zabbix服务API的命令行工具，它提供了有效的方式去查询和处理trigger 状态、主机最新数据和用户组。 cloudinsight-agent 提供可视化监控的saas平台cloudinsight开源的一个监控客户端。 Cloudinsight 探针可以收集它所在操作系统的各种指标，然后发送到 Cloudinsight 后端服务 owl OWL是TalkingData公司推出的一款开源分布式监控系统, 演示环境http://54.223.127.87/， 登录账号密码demo/demo SmartPing SmartPing为一个各机器(点)间间互PING检测工具，支持互PING，单向PING，绘制拓扑及报警功能。 系统设计为无中心化原则，所有的数据均存储自身点中，默认数据循环保留1个月时间，由自身点的数据绘制 出PING包 的状态，由各其他点的数据绘制 进PING包 的状态，并API接口获取其他点数据绘制整体PING拓扑图，拓扑图中存在报警功能。 容器技术 项目 简介 Pouch Pouch 是 Alibaba 公司开源的容器引擎技术，其主要功能包括基本的容器管理能力，安全稳定的强容器隔离能力，以及对应用无侵入性的富容器技术。 SwarmKit SwarmKit 是Docker公司开源的Docker集群管理和容器编排工具，其主要功能包括节点发现、基于raft算法的一致性和任务调度等。 DaoliNet DaoliNet是一个软件定义网络(SDN)系统，其设计目的是为Docker容器提供动态、高效的链接。在Docker容器中，微服务工作负载具有轻量且短暂的性质，DaoliNet恰好适用于这种性质。 Harbor 容器应用的开发和运行离不开可靠的镜像管理。从安全和效率等方面考虑，部署在私有环境内的Registry是非常必要的。Project Harbor是由VMware公司中国团队为企业用户设计的Registry server开源项目，包括了权限管理(RBAC)、LDAP、审计、管理界面、自我注册、HA等企业必需的功能，同时针对中国用户的特点，设计镜像复制和中文支持等功能 REX-Ray REX-Ray 是一个 EMC {code} 团队领导的开源项目，为 Docker、Mesos 及其他容器运行环境提供持续的存储访问。其设计旨在囊括通用存储、虚拟化和云平台，提供高级的存储功能。 Clair Clair 是一个容器漏洞分析服务。它提供一个能威胁容器漏洞的列表，并且在有新的容器漏洞发布出来后会发送通知给用户。 Weave Weave 创建一个虚拟网络并连接到部署在多个主机上的 Docker 容器。 Rocket Rocket （也叫 rkt）是 CoreOS 推出的一款容器引擎，和 Docker 类似，帮助开发者打包应用和依赖包到可移植容器中，简化搭环境等部署工作。Rocket 和 Docker 不同的地方在于，Rocket 没有 Docker 那些为企业用户提供的“友好功能”，比如云服务加速工具、集群系统等。反过来说，Rocket 想做的，是一个更纯粹的业界标准。 libnetwork Libnetwork 提供一个原生 Go 实现的容器连接，是容器的网络。libnetwork 的目标是定义一个健壮的容器网络模型（Container Network Model），提供一个一致的编程接口和应用程序的网络抽象。 Wormhole WWormhole 是一个能识别命名空间的由 Socket 激活的隧道代理。可以让你安全的连接在不同物理机器上的 Docker 容器。可以用来完成一些有趣的功能，例如连接运行在容器本机的服务或者在连接后创建按需的服务。 Shipyard Shipyard 是一个基于 Web 的 Docker 管理工具，支持多 host，可以把多个 Docker host 上的 containers 统一管理；可以查看 images，甚至 build images；并提供 RESTful API 等等。 Shipyard 要管理和控制 Docker host 的话需要先修改 Docker host 上的默认配置使其支持远程管理。 Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架或包装系统。 scope 一个docker&kubernetes的管理，监控可视化工具， 可以看到容器间的拓扑关系和tcp通信 habitus 一个快速实现docker build 流程的工具， 支持复杂的docker build流程，实现多个dockerfile的build流程，典型应用如将需要静态编译的程序，如go， java这类程序在一个docker build编译好之后，得到的二进制包用到后续的build流程 sextant sextant 提供了可以通过PXE全自动化安装初始化一个CoreOS+kubernetes集群。 KubeVirt KubeVirt 是一个围绕 Kubernetes 构建的虚拟机管理架构。使用 KubeVirt 可声明：创建预定义的 VM，在 Kubernetes 集群上调度 VM（启动 VM，停止 VM，删除 VM）｜ PaaS工具 项目 简介 Kel Kel 是一个开源的基于 Kubernetes 构建的 PaaS 系统，采用 Python 和 Go 语言开发。Kel 可简化管理 Web 应用发布和托管整个软件生命周期。Kel 帮助开发和运维人员轻松管理他们的应用架构，通过一组工具和组件让 K8S 使用非常简单。 CloudFoundry-Mesos Cloud Foundry-Mesos框架由华为与Mesosphere的工程师合作完成，能够为应用提供安全可靠的、可伸缩、可扩展的云端运行环境，并且应用能够 享用Cloud Foundry生态圈内各类丰富的服务资源。企业能够通过Cloud Foundry开发云应用，并通过Cloud Foundry-Mesos将应用部署到DCOS上，使应用能够与DCOS上安装的其他服务及应用框架共享资源，实现资源利用率最大化，能够大幅降低企业 数据中心运营成本。DCOS能够运行在虚拟和物理环境上，能够支持Linux（以及很快支持Windows），并可适用于私有云、公有云及混合云环境。 Flynn Flynn 是一个开源的 PaaS 系统，由 Docker 开发。采用 Go 语言编写。支持数据库包括 Postgres、Redis 和 MongoDB. Flynn 使用完全组件化模块化的设计，任何一个组件和模块都可以独立的进行替换。 DINP DINP是又一个基于Docker开发的PaaS平台。 Kubernetes Kubernetes 是来自 Google 云平台的开源容器集群管理系统。基于 Docker 构建一个容器的调度服务。该系统可以自动在一个容器集群中选择一个工作容器供使用。其核心概念是 Container Pod。 Tsuru 在 Tsuru 的 PaaS 服务下，你可以选择自己的编程语言，选择使用 SQL 或者 NoSQL 数据库，memcache、redis、等等许多服务，甚至与你可以使用 Git 版本控制工具来上传你应用。 atlantis Atlantis 是一款基于 Docker，使用 Go 编写，为 HTTP 应用准备的开源 PaaS。Atlantis 可以在路由请求中轻松的构建和部署应用到容器。Atlantis 在 Ooyala 的新应用中得到了很广泛的应用。 lain Lain 是一个基于 docker 的 PaaS 系统。其面向技术栈多样寻求高效运维方案的高速发展中的组织，devops 人力缺乏的 startup ，个人开发者。统一高效的开发工作流，降低应用运维复杂度；在 IaaS / 私有 IDC 裸机的基础上直接提供应用开发，集成，部署，运维的一揽子解决方案。 OpenDCP OpenDCP是一个基于Docker的云资源管理与调度平台，集镜像仓库、多云支持、服务编排、服务发现等功能与一身，支持服务池的扩缩容，其技术体系源于微博用于支持节假日及热点峰值流量的弹性调度DCP系统。OpenDCP允许利用公有云服务器搭建起适应互联网应用的IT基础设施，并且将运维的工作量降到最低。 Swan Swan 是一个基于 mesos 的新 HTTP API，使用 golang 开发。你可以使用 swan 在 mesos 集群上部署应用程序，并管理应用程序的整个生命周期，还可以使用新版本进行滚动更新，扩展应用程序，并且可以在应用程序或服务不可用时对应用程序和自动故障转移进行运行状况检查。 Deis Deis是一个基于Docker和CoreOS的开源PaaS平台，旨在让部属和管理服务器上的应用变得轻松容易。它可以运行在AWS、GCE以及Openstack平台下。详情，可了解 《Deis v1.0正式发布！》。 大数据&ML 项目 简介 MLF 弥勒佛项目是一个大数据机器学习框架。具有为处理大数据优化，可随业务增长scale up，模型的训练和使用都可以作为library或者service整合到在生产系统中，具有丰富的模型，高度可扩展，高度可读性，适合初学者进行大数据模型的学习等特点 Glow glow 是使用 Go 编写的易用分布式计算系统，是 Hadoop Map Reduce，Spark，Flint，Samza 等等的替代品。Glow 的目标是提供一个库，可以在并行线程或者分布式集群机器中进行更简单计算。 goml 机器学习的库, 包含了许多工具，能让你以在线方式学习其频道的数据内容。 Golearn GoLearn实现了熟悉的Scikit-learn 适应/预测界面，可实现快速预估测试和交换。GoLearn是一个成熟的项目，它提供了交叉验证和训练/测试等辅助功能。 Gorgonia 这个机器学习资料库完全是用Go语言编写而成，据其开发者“chewxy”称能“ 提供动态建立神经网络及相关算法必需条件 。” poseidon Poseidon 系统是一个日志搜索平台，可以在数百万亿条、数百PB大小的日志数据中快速分析和检索特定字符串。该系统可以应用于任何结构化或非结构化海量(从万亿到千万亿规模)数据的查询检索需求)。 微服务 项目 简介 micro Micro是一个专注于简化分布式系统开发的微服务生态系统。可插拔的插件化设计，提供强大的可插拔的架构来保证基础组件可以被灵活替换。 kite 一个基于go语言的微服务框架, Kite是Koding公司内部的一个框架, 该框架提供服务发现，多种认证功能，服务端通过RPC进行通信，同时还提供了websocket的js库，方便浏览器于服务器间进行通信。 goa Goa 是一款用 Go 用于构建微服务的框架，采用独特的设计优先的方法。 Go-kit Go-kit 是一个 Go 语言的分布式开发包，用于开发微服务。 Hprose Hprose 是高性能远程对象服务引擎（High Performance Remote Object Service Engine）的缩写 —— 微服务首选引擎。它是一个先进的轻量级的跨语言跨平台面向对象的高性能远程动态通讯中间件。它不仅简单易用，而且功能强大。你只需要稍许的时间去学习，就能用它轻松构建跨语言跨平台的分布式应用系统了。 Gizmo 纽约时报开源的go微服务工具.提供如下特性:标准化配置和日志;可配置策略的状态监测端点;用于管理 pprof 端点和日志级别的配置;结构化日志，提供基本请求信息;端点的有用度量;优雅的停止服务; 定义期待和词汇的基本接口 hystrix-go 用来隔离远程系统调用， 第三方库调用 ，服务调用， 提供熔断机制，避免雪崩效应的库， Hystrix的go 版本。 注Hystrixs是Netflix开源的一个java库 gateway Gateway是一个使用go实现的基于HTTP的API 网关。特性 ：API 聚合 ; 流控; 熔断; 负载均衡; 健康检查; 监控; 消息路由; 后端管理WebUI . 能做什么：规划更友好的URL给调用者。聚合多个API的结果返回给API调用者，利于移动端，后端可以实现原子接口。保护后端API服务不会被突发异常流量压垮。提供熔断机制，使得后端API Server具备自我恢复能力。借助消息路由能力，实现灰度发布，AB测试。 fabio fabio 是 ebay 团队用 golang 开发的一个快速、简单零配置能够让 consul 部署的应用快速支持 http(s) 的负载均衡路由器。这里有一篇中文文章http://dockone.io/article/1567介绍了如何用fabio＋consul实现服务发现，负载均衡，并阐述了原理， 最后还有demo程序 appdash go版本的分布式应用跟踪系统， 基于google dapper的原理构建 Jaeger Jaeger是Uber的分布式跟踪系统 ，基于google dapper的原理构建， 以Cassandra作为存储层 CI/CD 项目 简介 Cyclone Cyclone 是一个打造容器工作流的云原生持续集成持续发布平台，简单易用，使用 Go 语言开发，有详尽的中文文档 Drone Drone 是一个基于 Docker 的持续发布平台，使用 Go 语言开发 数据库技术 项目 简介 LedisDB ledisdb是一个参考ssdb，采用go实现，底层基于leveldb，类似redis的高性能nosql数据库，提供了kv，list，hash以及zset数据结构的支持。 BuntDB 是纯Go开发的、低层级的（low-level）的、可嵌入的key/value内存数据库（IMDB），数据持久化存储，遵从ACID，支持自定义索引和geospatial 数据。 Cockroach CockroachDB (蟑螂数据库）是一个可伸缩的、支持地理位置处理、支持事务处理的数据存储系统。CockroachDB 提供两种不同的的事务特性，包括快照隔离（snapshot isolation，简称SI）和顺序的快照隔离（SSI）语义，后者是默认的隔离级别。 qb-go qb是用来让使更容易使用数据库的go语言的数据库工具包。它受Python最喜欢的ORM SQLAlchemy的启发，既是一个ORM，也是一个查询生成器。它在表达api和查询构建东西的情形下是相当模块化的。 GoshawkDB GoshawkDB 是一个采用 Go 语言开发支持多平台的分布式的对象存储服务，支持事务以及容错。GoshawkDB 的事务控制是在客户端完成的。GoshawkDB 服务器端使用 AGPL 许可，而 Go 语言客户端使用 Apache 许可证 Codis Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别 (不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务. Cayley Cayley 是 Google 的一个开源图(Graph)数据库，其灵感来自于 Freebase 和 Google 的 Knowledge Graph 背后的图数据库。 Redigo Redigo 是 Redis 数据库的 Go 客户端。 radix.v2 radix.v2是redis官方推荐的客户端之一，相比于redigo,radix.v2特点是轻量、接口实现优雅、API友好 redis-go-cluster redis-go-cluster 是基于 Redigo 实现的 Golang Redis 客户端。redis-go-cluster 可以在本地缓存 slot 信息，并且当集群修改的时候会自动更新。此客户端管理每个节点连接池，使用 goroutine 来尽可能的并发执行，达到了高效，低延迟。 elastic elastic是开源搜索引擎elasticsearch的golang客户端，API友好，支持绝大部分es的接口,支持的es版本全面，从1.x到最新的6.x全覆盖 Dgraph dgraph 是可扩展的，分布式的，低延迟图形数据库。DGraph 的目标是提供 Google 生产水平的规模和吞吐量，在超过TB的结构数据里，未用户提供足够低延迟的实时查询。DGraph 支持 GraphQL 作为查询语言，响应 JSON。 DegDB DegDB 是分布式的经济图数据库。 Vitess outube出品的开源分布式MySQL工具集Vitess，自动分片存储MySQL数据表，将单个SQL查询改写为分布式发送到多个MySQL Server上，支持行缓存（比MySQL本身缓存效率高），支持复制容错，已用于Youtube生产环境 xuncache xuncache 是免费开源的NOSQL(内存数据库) 采用golang开发,简单易用而且 功能强大(就算新手也完全胜任)、性能卓越能轻松处理海量数据,可用于缓存系统. pgweb gweb 是一个采用 Go 语言开发的基于 Web 的 PostgreSQL 管理系统。 Orchestrator MySQL 复制拓扑可视化工具 mysql-schema-sync mysql-schema-sync 是一款使用go开发的、跨平台的、绿色无依赖的 MySQL 表结构自动同步工具。用于将线上(其他环境)数据库结构变化同步到测试（本地）环境! TiDB TiDB 是国内 PingCAP 团队开发的一个分布式 SQL 数据库。其灵感来自于 Google 的 F1, TiDB 支持包括传统 RDBMS 和 NoSQL 的特性。 kingshard 一个高性能的mysql中间件， 支持读写分离， 数据分片， 安全审计等功能 influxdb 一个可以水平扩展的时间序列数据库， 内建http api， 支持对数据打tag，灵活的查询策略和数据的实时查询，支持类sql语句进行查询 DBShield DBShield 是用 Go 语言开发的数据库防火墙，用来保护你的数据免受 SQL 注入的侵扰。支持的数据库包括：DB2、MySQL、MariaDB、Oracle、PostgreSQL。 存储技术 项目 简介 Torus Torus是一种针对容器集群量身打造的存储系统，可以为通过Kubernetes编排和管理的容器集群提供可靠可扩展的存储。这是继etcd、rkt、flannel，以及CoreOS Linux之后CoreOS发布的另一个开源产品。 Afero Afero 是一个文件系统框架，提供一个简单、统一和通用的 API 和任何文件系统进行交互，作为抽象层还提供了界面、类型和方法。Afero 的界面十分简洁，设计简单，舍弃了不必要的构造函数和初始化方法。Afero 作为一个库还提供了一组可交互操作的后台文件系统，这样在与 Afero 协作时，还可以保留 os 和 ioutil 软件包的功能和好处。 REX-Ray REX-Ray 是一个 EMC {code} 团队领导的开源项目，为 Docker、Mesos 及其他容器运行环境提供持续的存储访问。其设计旨在囊括通用存储、虚拟化和云平台，提供高级的存储功能。 SeaweedFS SeaweedFS 是简单，高伸缩性的分布式文件系统，包含两部分：存储数十亿的文件；快速为文件服务。SeaweedFS 作为支持全 POSIX 文件系统语义替代，Seaweed-FS 选择仅实现 key-file 的映射，类似 \"NoSQL\"，也可以说是 \"NoFS\"。 bfs bfs 是使用 Go 编写的分布式文件系统（小文件存储）。 IPFS IPFS 是分布式文件系统，寻求连接所有计算机设备的相同文件系统。在某些方面，这很类似于原始的 Web 目标，但是 IPFS 最终会更像单个比特流群交换的 git 对象。IPFS ＝ InterPlanetary File System Gotgt Gotgt 是使用 Go 编写的高性能、可扩展的 iSCSI target 服务。 Etcd & Fleet etcd是由CoreOS开发并维护键值存储系统，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。目前，Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。详情，可了解 《Etcd：用于服务发现的键值存储系统》。 Fleet则是一个分布式的初始化系统。它们之所以选择使用Go语言，则是因为Go语言对跨平台的良好支持，以及其背后的强大社区。 Syncthing 一款用Go语言编写的开源云存储和同步服务工具，用户的数据将由自己完全控制，所有的通信全都加密，每个访问节点都用加密证书验证。该项目被认为是Dropbox和 BitTorrent Sync的开源替代， 详情。Syncthing之所以选择Go语言，也是出于跨平台考虑。 cache2go 比较简单的一个缓存库，代码量很少，适合新手学习，可以学习到锁、goroutines等。 groupcache 与memcached同一作者，相当于是memcached的go语言实现。 分布式系统 项目 简介 Confd Confd是一个轻量级的配置管理工具。通过查询Etcd，结合配置模板引擎，保持本地配置最新，同时具备定期探测机制，配置变更自动reload。 zerg 基于docker的分布式爬虫服务 Doorman Doorman 是一个客户端速率限制的解决方案，客户端与共享资源进行通讯，包括数据库、gRPC 服务、RESTful API 等等可使用 Doorman 来限制对资源的调用。Doorman 使用 Go 语言开发，使用 gRPC 的通讯协议。其高可用特性需要一个分布式的锁管理器，当前支持 etcd，也可使用 Zookeeper 替代。 mgmt mgmt 是一个分布式的，事件驱动的配置管理工具。该工具支持并行执行，其 librarification 作为新的及已存在的软件的基础管理工具。 Yoke Yoke 是 Postgres 的高可用集群，具有自动切换和自动集群恢复。Postgres冗余/自动故障转移解决方案，提供一个高可用PostgreSQL集群的简单管理。 SeaweedFS SeaweedFS 是简单，高伸缩性的分布式文件系统，包含两部分：存储数十亿的文件；快速为文件服务。SeaweedFS 作为支持全 POSIX 文件系统语义替代，Seaweed-FS 选择仅实现 key-file 的映射，类似 \"NoSQL\"，也可以说是 \"NoFS\"。 Glow Glow 是使用 Go 编写的易用分布式计算系统，是 Hadoop Map Reduce，Spark，Flint，Samza 等等的替代品。Glow 的目标是提供一个库，可以在并行线程或者分布式集群机器中进行更简单计算。 Nomad Nomad 是一个集群管理器和调度器，专为微服务和批量处理工作流设计。Nomad 是分布式，高可用，可扩展到跨数据中心和区域的数千个节点。 dcmp DCMP是分布式配置管理平台。提供了一个etcd的管理界面，可通过界面修改配置信息，借助confd可实现配置文件的同步。 gleam 此处是一个通过Go和LuaJIT编写的快速和可扩展的分布式map/reduce系统，很好的将Go的高并发性与Luajit高性能相结合，可独立运行或用于分布式计算。 消息系统 项目 简介 KiteQ KiteQ 是一个基于 go + protobuff 实现的多种持久化方案的 mq 框架（消息队列）。 NSQ NSQ 是无中心设计、节点自动注册和发现的开源消息系统。可作为内部通讯框架的基础，易于配置和发布。 kingtask kingtask是一个由Go开发的轻量级的异步定时任务系统。支持定时的异步任务。 支持失败重试机制，重试时刻和次数可自定义。 任务执行结果可查询。 Go Machinery Machinery 是一个 Go 语言的异步任务队列和作业队列，基于分布式消息传递。类似 Python 的 Celery 框架。 kaca kaca 是用 golang 语言开发的基于 websocket 协议的消息发布/订阅系统。 服务器管理 项目 简介 Sharkey Sharkey 是OpenSSH管理证书使用的服务。Sharkey 分为客户端组件和服务端组件，服务端负责发布已签署的主机证书，客户端负责在机器上安装主机证书。 OSinstall CloudBoot”(OSinstall)云装机平台，是金融云初创公司杭州云霁科技推出的一款X86服务器全自动装机工具，遵循Apache协议，完全开源免费。全自动构建物理机资源池，像创建虚拟机一样方便的安装物理机。 ssh2go ssh2go 是对libssh的golang 封装。libssh是SSH的代码库，同时支持服务端和客户端，日常所见的ssh, sshd, scp, sftp均基于libssh。ssh2go是对libssh的Go语言绑定， 100%的libssh接口都可用，同时集成示例，方便参考。 Gooverssh gooverssh 是基于gosshtool的一个ssh开发包开发的一个基于ssh本地端口转发服务小应用，可以方便突破一些网络限制，如通过ssh代理访问内网数据库服 gosshtool gosshtool provide some useful functions for ssh client in golang.implemented using golang.org/x/crypto/ssh.go语言中提供ssh相关操作，支持ssh本地端口转发服务 teleport teleport 是 初创公司Gravitational 的一款基于ssh和https的远程管理linux 集群服务器的工具， 其特点是支持双重校验登陆；操作记录回放；session共享，便于协作排障；自动发现集群的服务器和容器 安全工具 项目 简介 gomitmproxy GomitmProxy是想用golang语言实现的mitmproxy，主要实现http代理，目前实现了http代理和https抓包功能。 Hyperfox Hyperfox 是一个安全的工具用来代理和记录局域网中的 HTTP 和 HTTPS 通讯。 Gryffin Gryffin 是雅虎开发的一个大规模 Web 安全扫描平台。它不是另外一个扫描器，其主要目的是为了解决两个特定的问题 —— 覆盖率和伸缩性。 ngrok ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 网络工具 项目 简介 DaoliNet DaoliNet是一个软件定义网络(SDN)系统，其设计目的是为Docker容器提供动态、高效的链接。在Docker容器中，微服务工作负载具有轻量且短暂的性质，DaoliNet恰好适用于这种性质。 Seesaw Seesaw 是 Google 开源的一个基于 Linux 的负载均衡系统。Seesaw 包含基本的负载均衡特性，同时支持一些高级的功能，诸如：anycast, Direct Server Return (DSR), 支持多个 VLANs 和集中式配置。同时其设计的宗旨是易于维护。需要注意的是，尽管该项目挂靠在 Google 名下，但并非 Google 官方产品。 TcpRoute2 TcpRoute, TCP 层的路由器。对于 TCP 连接自动从多个线路(允许任意嵌套)、多个域名解析结果中选择最优线路。TcpRoute2 是 golang 重写的版本。通过 socks5 代理协议对外提供服务。代理功能拆分成了独立的库，详细代理url格式级选项请参见 ProxyClient，目前支持直连、socks4、socks4a、socks5、http、https、ss 代理线路 Gor Gor 是用 Go 编写的简单 HTTP 流量复制工具，主要是为了从生产服务器返回流量到开发环境。使用 Gor 可以在实际的用户会话中测试代码。 Traefik Træfɪk 是一个新型的http反向代理、负载均衡软件，能轻易的部署微服务. 它支持多种后端 (Docker, Swarm, Mesos/Marathon, Consul, Etcd, Zookeeper, BoltDB, Rest API, file...) ,可以对配置进行自动化、动态的管理. TChannel TChannel 是用于 RPC 的网络复用和成帧协议。 go-tcp-proxy go-tcp-proxy是一个简单的tcp代理， 可以用于tcp端口转发， 也可以用做http代理使用 myLG myLG是一个开源的网络工具集，它包含了很多不同类型的网络诊断工具, 功能包括ping，trace， bgp， dns lookup， 端口扫描， 局域网网络发现，提供web界面, tcpdump等 cow COW 是一个简化穿墙的 HTTP 代理服务器。它能自动检测被墙网站，仅对这些网站使用二级代理；支持多种协议：sock5、http、shadow、cow Web工具 项目 简介 Tyk Tyk 是一个开源的、轻量级的、快速可伸缩的 API 网关，支持配额和速度限制，支持认证和数据分析，支持多用户多组织，提供全 RESTful API。 Shortme 用Golang编写的URL短链接服务。 WuKongSearch WuKong 是一个全文搜索引擎。功能特性有：高效索引和搜索（1M条微博500M数据28秒索引完，1.65毫秒搜索响应时间，19K搜索QPS）；支持中文分词（使用sego分词包并发分词，速度27MB/秒）；支持计算关键词在文本中的紧邻距离（token proximity）；支持计算BM25相关度；支持自定义评分字段和评分规则；支持在线添加、删除索引；支持持久存储；可实现分布式索引和搜索等 Pholcus Pholcus（幽灵蛛）是一款纯Go语言编写的高并发、分布式、重量级爬虫软件，支持单机、服务端、客户端三种运行模式，拥有Web、GUI、命令行三种操作界面；规则简单灵活、批量任务并发、输出方式丰富（mysql/mongodb/csv/excel等）、有大量Demo共享；同时她还支持横纵向两种抓取模式，支持模拟登录和任务暂停、取消等一系列高级功能。 Codetainer Codetainer 可以让你创建基于浏览器上的代码运行沙箱，可方便的嵌入到你的 Web 应用中。你可以把它当成是 codepicnic.com 的开源克隆) . GoTTY GoTTY 是个简单的命令行工具，可以把 CLI 工具共享成 Web 应用。GoTTY 可以把终端作为 Web 应用共享。 TermUI Go语言编写的终端仪表盘 Hound 快如闪电的代码搜索开源工具 goim goim 是一个支持集群的im及实时推送服务（支持websocket，http和tcp协议） fasthttp asthttp 是 Go 的快速 HTTP 实现，当前在 1M 并发的生产环境使用非常成功，可以从单个服务器进行 100K qps 的持续连接。HTTP 服务器性能与 net/http 比较，fasthttp 比 net/http 快 10 倍 netgraph netgraph 是一个 Go 语言编写的跨平台的 B/S 架构的 HTTP 抓包工具，方便在 Linux 服务器上直接查看 HTTP 包。 gohttp gohttp是一个http的文件服务器，功能有：各种文件的预览功能，实时的目录zip打包下载，二维码扫描下载的支持，苹果应用的在线安装，文件上传等 API-front API front是 HTTP API 前端，可进行请求代理转发、协议抓包分析、流量复制。主要是用于开发测试环境,用来解决开发测试环境多变等问题 esumable file uploads 实现文件上传的断点续传功能， 整套功能包含了协议实现，client， server。 client及server有多种语言的实现包括go， python， node等｜ pproxy http抓包代理程序,http协议调试工具 hystrix-go 用来隔离远程系统调用， 第三方库调用 ，服务调用， 提供熔断机制，避免雪崩效应的库， Hystrix的go 版本。 注Hystrixs是Netflix开源的一个java库 Web框架 项目 简介 Iris-Go 通过Iris-Go，可以方便的帮助你来开发基于web的应用。简单来说：Iris-Go与国内大牛的BeeGo类似，但从其官方介绍的资料来看，Iris-Go的性能更优！ Baa Baa 一个简单高效的Go web开发框架。主要有路由、中间件，依赖注入和HTTP上下文构成。 Orivil Orivil 是由 golang 开发的全新 web 框架，灵感来源于 Laravel 及 Symfony。 ecgo ecgo 是一个易学、易用、易扩展的go web开发框架 Gin Gin 是一个用 Go 语言开发的 Web 框架，提供类 Martini 的 API，但是性能更好。因为有了 httprouter 性能提升了 40 倍之多。 Melody Melody 是一个 Go 语言的微型 WebSocket 框架，基于 github.com/gorilla/websocket 开发， utron utron 是一个 Go 语言轻量级的 MVC 框架，用于快速构建可伸缩以及可靠的数据库驱动的 Web 应用。 Lessgo Lessgo 是一款 Go 语言编写的简单、稳定、高效、灵活的 web 完全开发框架。它的项目组织形式经过精心设计，实现前后端分离、系统与业务分离，完美兼容MVC与MVVC等多种开发模式，非常利于企业级应用与API接口的开发。当然，最值得关注的是它突破性地支持了运行时路由重建，开发者可在Admin后台轻松实现启用/禁用模块与操作，添加/移除中间件等功能！同时，它推荐以HandlerFunc与MiddlewareFunc为基础的函数式编程，也令开发变得更加灵活富有趣味性。 Hopen Golang web极速开发框架。 Faygo Faygo 是一款快速、简洁的Go Web框架，可用极少的代码开发出高性能的Web应用程序（尤其是API接口）。只需定义 struct Handler，Faygo 就能自动绑定、验证请求参数并生成在线API文档。 beego beego是一个用Go开发的应用框架，思路来自于tornado，路由设计来源于sinatra，beego入门文档 Beego源码分析 Revel Revel是一个高生产力的Go语言Web框架。Revel框架支持热编译，当编辑、保存和刷新源码时，Revel会自动编译代码和模板；全栈特性，支持路由、参数解析、缓存、测试、国际化等功能。Revel中文社区 一步一步学习Revel Web开源框架 Martini Martini 是一个非常新的 Go 语言的 Web 框架，使用 Go 的 net/http 接口开发，类似 Sinatra 或者 Flask 之类的框架，你可使用自己的 DB 层、会话管理和模板。 Tango Tango，微内核可扩展的Go语言Web框架。同时支持函数和结构体作为执行体，插件丰富。Tango，微内核可扩展的Go语言Web框架 Macaron Macaron 是一个具有高生产力和模块化设计的 Go Web 框架。框架秉承了 Martini 的基本思想，并在此基础上做出高级扩展。 Web.go web.go 跟 web.py 类似，但使用的是 Go 编程语言实现的 Web 应用开发框架。Go发布没多久该框架就诞生了，差不多是最早的Go框架。目前已经有段时间没有更新了。不过，该框架代码不多，其源码可以读一读。 Echo Echo 是个快速的 HTTP 路由器（零动态内存分配），也是 Go 的微型 Web 框架。 web goku goku官网 区块链技术 项目 简介 fabric Fabric是一个开源区块链实现，开发环境建立在VirtualBox虚拟机上，部署环境可以自建网络，也可以直接部署在BlueMix上，部署方式可传统可docker化，共识达成算法插件化，支持用Go和JavaScript开发智能合约，尤以企业级的安全机制和membership机制为特色。你要是不知道这些术语什么意思，就记住一点，Fabric之于区块链，很可能正如Hadoop之于大数据。 go-ethereum go-ethereum客户端通常被称为geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。通过安装和运行geth，可以参与到以太坊前台实时网络并进行以下操作：a. 挖掘真的以太币 b. 在不同地址间转移资金 c .创建合约，发送交易 d . 探索区块历史 e.很多其他功能 chain 金融领域的区块链项目 . Chain是由一家刚成立两年的美国创业公司Chain推出，是一个企业级的区块链平台架构，可以让机构构造从零开始更好的金融服务。Chain 开放标准在以下方面实现突破：• 全新的共识模型在不到一秒的时间里实现交易的最终完成，即便是交易量非常大也能支持;• 私密解决方案对区块链数据进行加密，并让相关对手方和监管者进行有选择的读取;• 智能合约框架和虚拟机支持简单的规则执行，以及进行键值存储的图灵完整程序; • 可伸缩的数据模型可以为网络参与者降低运行负荷; • 丰富的元数据层可支持满足KYC（了解你的客户）和 AML（反洗钱）要求 其它 项目 简介 kone 可用于家庭或者企业网络的透明代理，可用来翻墙等 KodeRunr KodeRunr (读作 code runner) 是款我在闲暇时间用Go语言编写的应用。顾名思义，你可以用它在网页上、命令行里写程序，贴代码，与此同时无需在本地安装任何编程语言。支持Ruby, Python, GO, Swift, C, Elixir等 godaemon godaemon是用来为应用增加daemon和graceful的。 Gomobile Gomobile是一个应用于iOS和Android的优秀跨平台开发库，为开发者提供用于创建Android和iOS 移动平台代码的工具。 gojieba \"结巴\"中文分词的Golang语言版本。 Cherry Cherry 是一个使用 Go 语言开发的 Web 聊天引擎。 MailSlurper MailSlurper 是一个便携的 SMTP 邮件服务器，对本地和团队应用开发来说非常有用。MailSlurper 体积小运行快速，支持 SQLite, MSSQL 和 MySQL. 数据库。 RobustIRC RobustIRC 是不会有网络中断情况的 IRC。RobustIRC 主要特性：服务器不可用的时候不会有网络中断； 可以使用标准 IRC 客户端； 健壮，可以很好处理客户端和网络的连接问题 Qor Qor 是基于 Golang 开发的的CMS 一系列工具库，基于 Qor可以快速搭建网站的后台管理系统。Qor 的工作库包含：1，后台管理：可以对数据库进去 CURD 管理，支持一对一，一对多，多对多关联关系维护等等； 2，支持上传图片到云以及 filesystem，resize、crop 图片等等 ；3，Publish 发布系统，可以修改数据，并且经过检查后，再发布到正式环境中； 4，状态机，可以用于开发工作流的系统； 5，I18n，翻译，可以通过在 WEB 界面翻译，并将翻译保存到数据库中； 6，L10n，本地化，不同于翻译，他可以针对某个地区来对内容，或者数据结构进行本地化。7，Roles，权限管理； 8，Exchange，通过 Excel，CSV 导入导出数据； 9，Worker，后台任务管理，可用于跑定时任务等等 FishChat FishChat（鱼传——鱼传尺素）分布式可伸缩 IM 服务器，是一款纯 golang 编写优秀的即时通讯软件(IM), 它集合了市面上已有产品的优点, 并具备 智能硬件网关管理(学习QQ物联思想, 构思中)。 goRBAC goRBAC 为 Go 语言应用提供了轻量级的基于角色的访问控制。 hey Boom 是 google 一女工程师使用 Go 语言开发的类似 apache ab 的性能测试工具。相比 ab，boom跨平台性更好，而且更容易安装。 Mattermost mattermost 是一个 Slack 的开源替代品。Mattermost 采用 Go 语言开发，这是一个开源的团队通讯服务。为团队带来跨 PC 和移动设备的消息、文件分享，提供归档和搜索功能。 glot glot 是可以可以在线运行各种编程语言代码片段的平台，项目采用 Haskell Script 、Go、Erlang 和 Shell 开发，运行环境基于 Docker 容器进行。 Lantern Lantern是一个点对点科学上网软件。 dog-tunnel 狗洞是一个高速的 P2P 端口映射工具，同时支持Socks5代理。 0.5版后开始开源，UDP底层基于开源库KCP重写，效率大大提高，在恶劣环境下优势明显。 同时提供非P2P版本（Lite版本），两端连接过程完全不依赖中间服务器，支持加密和登陆认证，自动重连，但是需要人为确保两端能正常连通（否则请使用默认的P2P版本） GRPC GRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持.GRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。 LiteIDE LiteIDE是一款开源、跨平台的轻量级Go语言集成开发环境（IDE）。 firefly-proxy 穿墙工具。 GFW梯子。 提供客户端和服务端。支持多个平台， 包括linux， macos， windows ，android wu 一个监听文件变化并自动执行某些操作的小工具 ，可以用于配置修改后自动重启web server apex 管理，部署aws lambda函数的工具， 支持用go语言编写lambda函数（注：目前aws官方不支持用go语言编写lambda函数，但是apex却可以变相支持） gosuv 进程管理， 类似于python的supervisord ， 提供了web管理界面 chaosmonkey Chaos Monkey是netflix公司开源的一个用于服务可用性测试的工具，通过有计划的在生产系统制造真实的故障（如cpu负载高， 内存溢出，磁盘写满，服务器宕机等）来检测系统的可用性。 scheduler scheduler专门进行任务的调度分发任务工作，各个任务的具体任务执行分配到各个项目中， 从而达到对任务的统一配置和管理。 该工具提供了web管理界面 hugo Hugo是由Go语言实现的静态网站生成器；简单、易用、高效、易扩展、快速部署；相比于Hexo、Jekyll，hugo的优势是生成速度极快。 Lime 相对上面的几款Go语言在云端和服务器端之外，Lime则显得比较特殊。Lime，则是一款用Go语言写的桌面编辑器程序，被看做是著名编辑器Sublime Text的开源实现。 Gogs Gogs则是一款由国人无闻（GitHub）开发的自助Git服务项目。Gogs的目标是打造一个最简单、最快速和最轻松的方式搭建自助Git服务。据作者称，之所以选择使用Go语言开发，就是Go允许Gogs可以通过独立的二进制分发，且对跨平台有良好支持。 蚂蚁笔记 MinDoc "},"notes/":{"url":"notes/","title":"编码规范指南","keywords":"","body":"Go 编码规范指南 序言 看过很多方面的编码规范，可能每一家公司都有不同的规范，这份编码规范是写给我自己的，同时希望我们公司内部同事也能遵循这个规范来写Go代码。 如果你的代码没有办法找到下面的规范，那么就遵循标准库的规范，多阅读标准库的源码，标准库的代码可以说是我们写代码参考的标杆。 格式化规范 go默认已经有了gofmt工具，但是我们强烈建议使用goimport工具，这个在gofmt的基础上增加了自动删除和引入包. go get golang.org/x/tools/cmd/goimports 不同的编辑器有不同的配置, sublime的配置教程 LiteIDE默认已经支持了goimports，如果你的不支持请点击属性配置->golangfmt->勾选goimports 保存之前自动fmt你的代码。 行长约定 一行最长不超过80个字符，超过的请使用换行展示，尽量保持格式优雅。go vet vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。 go get golang.org/x/tools/cmd/vet 使用如下：go vet . package名字 保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。 import 规范 import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式： import \"fmt\" 如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包： import ( \"encoding/json\" \"strings\" \"myproject/models\" \"myproject/controller\" \"myproject/utils\" \"github.com/astaxie/beego\" \"github.com/go-sql-driver/mysql\" ) 有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。 在项目中不要使用相对路径引入包： // 这是不好的导入 import \"../net\" // 这是正确的做法 import \"github.com/repo/proj/src/net\" 变量申明 变量名采用驼峰标准，不要使用_来命名变量名，多个变量申明放在一起 var ( Found bool count int ) 在函数外部申明必须使用var,不要采用:=，容易踩到变量的作用域的问题。 自定义类型的string循环问题 如果自定义的类型定义了String方法，那么在打印的时候会产生隐藏的一些bug type MyInt intfunc (m MyInt) String() string { return fmt.Sprint(m)//BUG:死循环 } func(m MyInt) String() string { return fmt.Sprint(int(m)) //这是安全的,因为我们内部进行了类型转换 } 避免返回命名的参数 如果你的函数很短小，少于10行代码，那么可以使用，不然请直接使用类型，因为如果使用命名变量很容易引起隐藏的bug func Foo(a int, b int) (string, ok){ } 当然如果是有多个相同类型的参数返回，那么命名参数可能更清晰： func (f *Foo) Location() (float64, float64, error) 下面的代码就更清晰了： // Location returns f's latitude and longitude. // Negative values mean south and west, respectively. func (f *Foo) Location() (lat, long float64, err error) 错误处理 错误处理的原则就是不能丢弃任何有返回err的调用，不要采用_丢弃，必须全部处理。接收到错误，要么返回err，要么实在不行就panic，或者使用log记录下来 error 信息 error的信息不要采用大写字母，尽量保持你的错误简短，但是要足够表达你的错误的意思。 长句子打印或者调用，使用参数进行格式化分行 我们在调用fmt.Sprint或者log.Sprint之类的函数时，有时候会遇到很长的句子，我们需要在参数调用处进行多行分割： 下面是错误的方式： log.Printf(“A long format string: %s %d %d %s”, myStringParameter, len(a), expected.Size, defrobnicate(“Anotherlongstringparameter”, expected.Growth.Nanoseconds() /1e6))` 应该是如下的方式： `log.Printf( “A long format string: %s %d %d %s”, myStringParameter, len(a), expected.Size, defrobnicate( “Anotherlongstringparameter”, expected.Growth.Nanoseconds()/1e6, ), ) 注意闭包的调用 在循环中调用函数或者goroutine方法，一定要采用显示的变量调用，不要再闭包函数里面调用循环的参数 fori:=0;iRace on loop counter 在逻辑处理中禁用panic 在main包中只有当实在不可运行的情况采用panic，例如文件无法打开，数据库无法连接导致程序无法正常运行，但是对于其他的package对外的接口不能有panic，只能在包内采用。 强烈建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序。 注释规范 注释可以帮我们很好的完成文档的工作，写得好的注释可以方便我们以后的维护。详细的如何写注释可以参考：Commentary bug注释 针对代码中出现的bug，可以采用如下教程使用特殊的注释，在godocs可以做到注释高亮： // BUG(astaxie):This divides by zero. var i float = 1/0 struct规范 struct申明和初始化格式采用多行： 定义如下： type User struct{ Username string Email string } 初始化如下： u := User{ Username: \"astaxie\", Email: \"astaxie@gmail.com\", } recieved是值类型还是指针类型 到底是采用值类型还是指针类型主要参考如下原则： func(w Win) Tally(playerPlayer)int // w不会有任何改变 func(w *Win) Tally(playerPlayer)int // w会改变数据 带mutex的struct必须是指针receivers 如果你定义的struct中带有mutex,那么你的receivers必须是指针 参考资料 代码审查注释 Effective Go "},"notes/gocmd.html":{"url":"notes/gocmd.html","title":"Go命令","keywords":"","body":"Go命令 Go命令教程 命令 解释 build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages go build 编译指定的源码文件或代码包以及它们的依赖包。go build [-o output] [-i] [build flags] [packages] -a强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。 -n打印编译期间所用到的其它命令，但是并不真正执行它们。 -p n指定编译过程中执行各任务的并行数量（确切地说应该是并发数量）。在默认情况下，该数量等于CPU的逻辑核数。但是在darwin/arm平台（即iPhone和iPad所用的平台）下，该数量默认是1。n为正整数 -race开启竞态条件的检测。不过此标记目前仅在linux/amd64、freebsd/amd64、darwin/amd64和windows/amd64平台下受到支持。 -v打印出那些被编译的代码包的名字。 -work打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。 -x打印编译期间所用到的其它命令。注意它与-n标记的区别。 -asmflags此标记可以后跟另外一些标记，如-D、-I、-S等。这些后跟的标记用于控制Go语言编译器编译汇编语言文件时的行为。 -buildmode此标记用于指定编译模式，使用方式如-buildmode=default（这等同于默认情况下的设置）。此标记支持的编译模式目前有6种。借此，我们可以控制编译器在编译完成后生成静态链接库（即.a文件，也就是我们之前说的归档文件）、动态链接库（即.so文件）或/和可执行文件（在Windows下是.exe文件）。 -gcflags此标记用于指定需要传递给go tool compile命令的标记的列表。go build -gcflags \"-N -l\" -o test test.go go clean 删除掉执行其它命令时产生的一些文件和目录，包括： 使用go build命令时在当前代码包下生成的与包名同名或者与Go源码文件同名的可执行文件。 执行go test命令并加入-c标记时在当前代码包下生成的以包名加“.test”后缀为名的文件。 还有一些目录和文件是在编译Go或C源码文件时留在相应目录中的。包括：“_obj”和“_test”目录，名称为“_testmain.go”、“test.out”、“build.out”或“a.out”的文件，名称以“.5”、“.6”、“.8”、“.a”、“.o”或“.so”为后缀的文件。这些目录和文件是在执行go build命令时生成在临时目录中的。go clean [-i] [-r] [-n] [-x] [build flags] [packages] -r，包括当前代码包的所有依赖包的上述目录和文件。 -i，同时删除安装当前代码包时所产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区的pkg目录的相应目录下的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区的bin目录下的可执行文件。 go doc 打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 go doc [-u] [-c] [package|[package.]symbol[.method]] -c加入此标记后会使go doc命令区分参数中字母的大小写。 -cmd打印出main包中的可导出的程序实体（其名称的首字母大写）的文档。 -u打印出不可导出的程序实体（其名称的首字母小写）的文档。 godoc是一个很强大的工具，同样用于展示指定代码包的文档。在Go语言的1.5版本以后，它是一个内置的标准命令。 godoc fmt godoc -http=:6060标记-http的值:6060表示启动的Web服务器使用本机的6060端口。之后，我们就可以通过在网络浏览器的地址栏中输入http://localhost:6060来查看以网页方式展现的Go文档了。 go env 用于打印Go语言的环境信息。 go env [var ...] Go语言的GOPATH与工作目录详解 go fix 用来修复以前老版本的代码到新版本。命令go fix其实是命令go tool fix的简单封装。这甚至比go fmt命令对gofmt命令的封装更简单。像其它的Go命令一样，go fix命令会先对作为参数的代码包导入路径进行验证，以确保它是正确有效的。 go fix [packages] -diff不将修正后的内容写入文件，而只打印修正前后的内容的对比信息到标准输出。 -r只对目标源码文件做有限的修正操作。该标记的值即为允许的修正操作的名称。多个名称之间用英文半角逗号分隔。 -force使用此标记后，即使源码文件中的代码已经与Go语言的最新版本相匹配了，也会强行执行指定的修正操作。该标记的值就是需要强行执行的修正操作的名称，多个名称之间用英文半角逗号分隔。 go fmt 格式化I / O的功能,和C的printf和scanf类似。golang 中fmt用法 / fmt包Printf 在go中，代码则有标准的风格 go fmt [-n] [-x] [packages] -n打印编译期间所用到的其它命令，但是并不真正执行它们。 -x可以看到go get命令执行过程中所使用的所有命令。 go generate是一个你可以用来自动自成Go代码的命令，你可以结合例如jsonenums(一个用于为枚举类型自动生成JSON编组样板代码的类库)这样的元编程来使用go generate快速自动实现重复乏味代码的编写。在Go标准类库里面已经有大量可以用于解析AST的接口，而AST使得编写元编程工具更简单，更容易。 go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。go get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages] -d让命令程序只执行下载动作，而不执行安装动作。 -f仅在使用-u标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里Fork过来的，那么这样做就尤为重要了。 -fix让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。之前解决相关性或建设中的代码。 -insecure允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。 -t让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。 -u让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 -x可以看到go get命令执行过程中所使用的所有命令 智能下载 命令go get还有一个很值得称道的功能。在使用它检出或更新代码包之后，它会寻找与本地已安装Go语言的版本号相对应的标签（tag）或分支（branch）。比如，本机安装Go语言的版本是1.x，那么go get 命令会在该代码包的远程仓库中寻找名为“go1”的标签或者分支。如果找到指定的标签或者分支，则将本地代码包的版本切换到此标签或者分支。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。 go install用于编译并安装指定的代码包及它们的依赖包。实际上，go install命令只比go build命令多做了一件事，即：安装编译后的结果文件到指定目录。go install [build flags] [packages] go list命令的作用是列出指定的代码包的信息。与其他命令相同，我们需要以代码包导入路径的方式给定代码包。被给定的代码包可以有多个。这些代码包对应的目录中必须直接保存有Go语言源码文件，其子目录中的文件不算在内。否则，代码包将被看做是不完整的。go list [-e] [-f format] [-json] [build flags] [packages] go run命令可以编译并运行命令源码文件。由于它其中包含了编译动作，因此它也可以接受所有可用于go build命令的标记。除了标记之外，go run命令只接受Go源码文件作为参数，而不接受代码包。与go build命令和go install命令一样，go run命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此。而原因也是一致的，多个命令源码文件会都有main函数声明。go run [build flags] [-exec xprog] gofiles... [arguments...]如果命令源码文件可以接受参数，那么在使用go run命令运行它的时候就可以把它的参数放在它的文件名后面，像这样：go run showds.go -p ~/golang/goc2p。 go test go test [build/test flags] [packages] [build/test flags & test binary flags] -c生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为“pkg.test”，其中的“pkg”即为被测试代码包的导入路径的最后一个元素的名称。 -i安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。 -o指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记-c或-i。 go tool go tool [-n] command [args...] go tool pprof命令来交互式的访问概要文件的内容。命令将会分析指定的概要文件，并会根据我们的要求为我们提供高可读性的输出信息。 go tool cgo这个工具可以使我们创建能够调用C语言代码的Go语言源码文件。这使得我们可以使用Go语言代码去封装一些C语言的代码库，并提供给Go语言代码或项目使用。 go version 查看Go版本 go vet 是一个用于检查Go语言源码中静态错误的简单工具 go vet [-n] [-x] [build flags] [packages] go vet命令是go tool vet命令的简单封装。它会首先载入和分析指定的代码包，并把指定代码包中的所有Go语言源码文件和以“.s”结尾的文件的相对路径作为参数传递给go tool vet命令。 *标记-n会让命令在执行过程中打印用到的系统命令，但不会真正执行它们。 *标记-x既打印命令又执行命令。 *标记-r，包括当前代码包的所有依赖包的上述目录和文件。 "},"notes/installation.html":{"url":"notes/installation.html","title":"环境搭建","keywords":"","body":"环境搭建 安装 sudo apt-get install golang 到官网去下需要的安装包wget https://storage.googleapis.com/golang/go1.6.2.linux-amd64.tar.gz tar -C /usr/local -zxf go1.6.2.linux-amd64.tar.gz 下载 本地路径(/usr/local/go)放在这个路径下就不用设GOROOT变量了。 - 卸载golang-go `sudo apt-get remove golang-go` - 卸载golang-go及其依赖 `sudo apt-get remove --auto-remove golang-go` - 卸载golang-go并删除其本地和配置文件 `sudo apt-get purge golang-go` - 卸载golang-go及其依赖并删除其本地和配置文件 `sudo apt-get purge --auto-remove golang-go` 环境变量 /etc/profile export GOPATH=/home/lbb/work/gopackage export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin Linux系统安装到/usr/local/不用设置$GOROOT,其他路径要设置 Sublime Text3 Golang开发环境搭建-Vim篇 github的vim-go-ide VIM Golang开发环境搭建-Vim篇 把vim当做golang的IDE 基于vim搭建Go开发环境 vim 安装vim-go 打造GOLANG 专用IDE 为Vim配置Golang开发环境 Atom 打造atom成为golang开发神器 "},"notes/govendor.html":{"url":"notes/govendor.html","title":"Go外部依赖管理","keywords":"","body":"Go 外部依赖管理 长期以来，golang 对外部依赖都没有很好的管理方式，只能从 $GOPATH 下查找依赖。这就造成不同用户在安装同一个项目适合可能从外部获取到不同的依赖库版本，同时当无法联网时，无法编译依赖缺失的项目。 自 1.5 版本开始引入 govendor 工具，该工具将项目依赖的外部包放到项目下的 vendor 目录下（对比 nodejs 的 node_modules 目录），并通过 vendor.json 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。 对于 govendor 来说，主要存在三种位置的包： 项目自身的包组织为本地（local）包； 传统的存放在 $GOPATH 下的依赖包为外部（external）依赖包； 被 govendor 管理的放在 vendor 目录下的依赖包则为 vendor 包。 具体来看，这些包可能的类型如下： 状态 缩写状态 含义 +local l 本地包，即项目自身的包组织 +external e 外部包，即被 $GOPATH 管理，但不在 vendor 目录下 +vendor v 已被 govendor 管理，即在 vendor 目录下 +std s 标准库中的包 +unused u 未使用的包，即包在 vendor 目录下，但项目并没有用到 +missing m 代码引用了依赖包，但该包并没有找到 +program p 主程序包，意味着可以编译为执行文件 +outside 外部包和缺失的包 +all 所有的包 常见的命令如下，格式为 govendor COMMAND。通过指定包类型，可以过滤仅对指定包进行操作。 命令 功能 init 初始化 vendor 目录 list 列出所有的依赖包 add 添加包到 vendor 目录，如 govendor add +external 添加所有外部包 add PKG_PATH 添加指定的依赖包到 vendor 目录 update 从 $GOPATH 更新依赖包到 vendor 目录 remove 从 vendor 管理中删除依赖 status 列出所有缺失、过期和修改过的包 fetch 添加或更新包到本地 vendor 目录 sync 本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本 get 类似 go get 目录，拉取依赖包到 vendor 目录 "},"notes/the-go-programming-language.html":{"url":"notes/the-go-programming-language.html","title":"Go语言圣经","keywords":"","body":"前言 Go 语言起源 Go语言项目 \"软件的复杂性是乘法级相关的-----Rob Pike\" 简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。 本书的组织 基础 第一章包含了本教程的基本结构，通过十几个程序介绍了用Go语言如何实现类似读写文件、文本格式化、创建图像、网络客户端和服务器通讯等日常工作。 第二章描述了Go语言程序的基本元素结构、变量、新类型定义、包和文件、以及作用域等概念。 第三章讨论了数字、布尔值、字符串和常量，并演示了如何显示和处理Unicode字符。 第四章描述了复合类型，从简单的数组、字典、切片到动态列表。 第五章涵盖了函数，并讨论了错误处理、panic和recover，还有defer语句。 第一章到第五章是基础部分，主流命令式编程语言这部分都类似。个别之处，Go语言有自己特色的语法和风格，但是大多数程序员能很快适应。其余章节是Go语言特有的：方法、接口、并发、包、测试和反射等语言特性。 进阶 第八章讨论了基于顺序通信进程(CSP)概念的并发编程，使用goroutines和channels处理并发编程。 第九章则讨论了传统的基于共享变量的并发编程。 第十章描述了包机制和包的组织结构。这一章还展示了如何有效地利用Go自带的工具，使用单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务。 第十一章讨论了单元测试，Go语言的工具和标准库中集成了轻量级的测试功能，避免了强大但复杂的测试框架。测试库提供了一些基本构件，必要时可以用来构建复杂的测试构件。 第十二章讨论了反射，一种程序在运行期间审视自己的能力。反射是一个强大的编程工具，不过要谨慎地使用；这一章利用反射机制实现一些重要的Go语言库函数, 展示了反射的强大用法。第十三章解释了底层编程的细节，在必要时，可以使用unsafe包绕过Go语言安全的类型系统。 入门 Hello, World 尝试用100中方法打印出Hello, World 哈哈! package main func main() { print(\"Hello, 世界\") //Go语言原生支持Unicode，它可以处理全世界任何语言的文本。 } 命令行参数 os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。 查找重复的行 bufio包，它使处理输入和输出方便又高效。Scanner类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。 格式化verb%d 十进制整数 %x, %o, %b 十六进制，八进制，二进制整数。 %f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00 %t 布尔：true或false %c 字符（rune） (Unicode码点) %s 字符串 %q 带双引号的字符串\"abc\"或带单引号的字符'c' %v 变量的自然形式（natural format） %T 变量的类型 %% 字面上的百分号标志（无操作数） ioutil.ReadFile(filename)函数返回一个字节切片（byte slice） GIF动画 生成的图形名字叫利萨如图形(Lissajous figures) 获取URL http.Get(url) ioutil.ReadAll(resp.Body) 并发获取多个URL goroutine和channel Web服务 package main import ( \"fmt\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", handler) // each request calls handler log.Fatal(http.ListenAndServe(\"localhost:8000\", nil)) } // handler echoes the Path component of the requested URL. func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"URL.Path = %q\\n\", r.URL.Path) } 如果你的请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。 要点 控制流 switch coinflip() { case \"heads\": heads++ case \"tails\": tails++ default: fmt.Println(\"landed on edge!\") Go语言并不需要显式地在每一个case后写break 如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。 命名类型 指针 指针是一种直接存储了变量的内存地址的数据类型。指针是可见的内存地址，&操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。 方法和接口 Go语言里的方法可以被关联到任意一种命名类型。 包 注释 程序结构 命名 25个关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 30多个预定义的名字 内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover Go语言程序员推荐使用 驼峰式 命名 声明 变量 简短变量声明 i := 100 指针 x := 1 p := &x // p, of type *int, points to x fmt.Println(*p) // \"1\" *p = 2 // equivalent to x = 2 fmt.Println(x) // \"2\" new函数 p := new(int) // p, *int 类型, 指向匿名的 int 变量 变量的生命周期 Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。 赋值 元组赋值 x, y = y, x a[i], a[j] = a[j], a[i] 可赋值性 可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。 类型 包和文件 导入包 \"fmt\" . \"fmt\" //省略包名 _ \"fmt\" //只导入 包的初始化 func init() { /* ... */ } 作用域 不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。 控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。 基础数据类型 整型 8、16、32、64bit 运算符*（乘） /（除） %（余） >（右移） &（位运算 AND） &^（位清空 (AND NOT)） +（加） -（减） | （位运算 OR） ^（位运算 XOR） ==（等于） != （不等于） （大于） >=（大于或等于） &&（AND） ||（OR） 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级 浮点数 float32和float64 // Copyright © 2016 Alan A. A. Donovan & Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 58. //!+ // Surface computes an SVG rendering of a 3-D surface function. package main import ( \"fmt\" \"math\" ) const ( width, height = 600, 320 // canvas size in pixels cells = 100 // number of grid cells xyrange = 30.0 // axis ranges (-xyrange..+xyrange) xyscale = width / 2 / xyrange // pixels per x or y unit zscale = height * 0.4 // pixels per z unit angle = math.Pi / 6 // angle of x, y axes (=30°) ) var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°) func main() { fmt.Printf(\"\", width, height) for i := 0; i \\n\", ax, ay, bx, by, cx, cy, dx, dy) } } fmt.Println(\"\") } func corner(i, j int) (float64, float64) { // Find point (x,y) at corner of cell (i,j). x := xyrange * (float64(i)/cells - 0.5) y := xyrange * (float64(j)/cells - 0.5) // Compute surface height z. z := f(x, y) // Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy). sx := width/2 + (x-y)*cos30*xyscale sy := height/2 + (x+y)*sin30*xyscale - z*zscale return sx, sy } func f(x, y float64) float64 { r := math.Hypot(x, y) // distance from (0,0) return math.Sin(r) / r } //!- 复数 Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部： 布尔型 字符串 \\a 响铃 \\b 退格 \\f 换页 \\n 换行 \\r 回车 \\t 制表符 \\v 垂直制表符 \\' 单引号 (只用在 '\\'' 形式的rune符号面值中) \\\" 双引号 (只用在 \"...\" 形式的字符串面值中) \\\\ 反斜杠 得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。我们可以不用解码直接测试一个字符串是否是另一个字符串的前缀：func HasPrefix(s, prefix string) bool { return len(s) >= len(prefix) && s[:len(prefix)] == prefix } 或者是后缀测试：func HasSuffix(s, suffix string) bool { return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix } 或者是包含子串测试：func Contains(s, substr string) bool { for i := 0; i package main import \"fmt\" func main() { s := \"Hello, 世界\" fmt.Printf(\"%s\\t%d\\n\", s, len(s)) for i := 0; i 结果 Hello, 世界 13 0 72 'H' 1 101 'e' 2 108 'l' 3 108 'l' 4 111 'o' 5 44 ',' 6 32 ' ' 7 228 'ä' 8 184 '¸' 9 150 '\\u0096' 10 231 'ç' 11 149 '\\u0095' 12 140 '\\u008c' ... 0 72 'H' 1 101 'e' 2 108 'l' 3 108 'l' 4 111 'o' 5 44 ',' 6 32 ' ' 7 19990 '世' 10 30028 '界' 字符串和Byte切片 标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。 strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。 bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。 strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。 unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。 字符串和数字的转换 常量 iota 常量生成器const ( _ = 1 复合数据类型 数组 Slice Slice内存技巧 Map 在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。 内置的make函数可以创建一个map： ages := make(map[string]int) // mapping from strings to ints 我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value： ages := map[string]int{ \"alice\": 31, \"charlie\": 34,} 使用内置的delete函数可以删除元素： delete(ages, \"alice\") // remove element ages[\"alice\"] 结构体 结构体比较 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的 结构体嵌入和匿名成员 需要注意的是Printf函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。 fmt.Printf(\"%#v\\n\", w) JSON json.Marshal和json.MarshalIndent json处理struct未导出成员 golang的结构体里的成员的名字如果以小写字母开头，那么其他的包是无法访问的，也就是json无法访问我们的结构体里小写字母开头的成员。两种解决方法 struct的成员用大写开头，然后加tag package main import ( \"encoding/json\" \"fmt\" \"log\" ) type Movie struct { Title string Year int `json:\"released\"` Color bool `json:\"color,omitempty\"` Actors []string } func main() { var movies = []Movie{ {Title: \"Casablanca\", Year: 1942, Color: false, Actors: []string{\"Humphrey Bogart\", \"Ingrid Bergman\"}}, {Title: \"Cool Hand Luke\", Year: 1967, Color: true, Actors: []string{\"Paul Newman\"}}, {Title: \"Bullitt\", Year: 1968, Color: true, Actors: []string{\"Steve McQueen\", \"Jacqueline Bisset\"}}, // ... } data, err := json.Marshal(movies) // json.MarshalIndent(struct, \"\", \" \") if err != nil { log.Fatalf(\"JSON marshaling failed: %s\", err) } fmt.Printf(\"%s\\n\", data) } [{\"Title\":\"Casablanca\",\"released\":1942,\"Actors\":[\"Humphrey Bogart\",\"Ingrid Bergman\"]},{\"Title\":\"Cool Hand Luke\",\"released\":1967,\"color\":true,\"Actors\":[\"Paul Newman\"]},{\"Title\":\"Bullitt\",\"released\":1968,\"color\":true,\"Actors\":[\"Steve McQueen\",\"Jacqueline Bisset\"]}] 实现json.Marshaler接口 ``` package main import ( \"encoding/json\" \"fmt\" ) func main() { var s S s.a = 5 s.b[0] = 3.123 s.b[1] = 111.11 s.b[2] = 1234.123 s.c = \"hello\" s.d[0] = 0x55 j, _ := json.Marshal(s) fmt.Println(string(j)) } type S struct { a int b [4]float32 c string d [12]byte } func (this S) MarshalJSON() ([]byte, error) { return json.MarshalIndent(map[string]interface{}{ // json.MarshalIndent(struct, \"\", \" \") \"a\": this.a, \"b\": this.b, \"c\": this.c, \"d\": this.d, }, \"\", \" \") } ``` {\"a\":5,\"b\":[3.123,111.11,1234.123,0],\"c\":\"hello\",\"d\":[85,0,0,0,0,0,0,0,0,0,0,0]} 文本和HTML模板 函数 函数声明 递归 多返回值 错误 函数值 匿名函数 可变参数 Deferred 函数 Panic 异常 一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程，在第8章会详细介绍）中被延迟的函数（defer 机制） Recover 捕获异常 方法 方法声明 基于指针对象的方法 通过嵌入结构体来扩展类型 方法值和方法表达式 Bit数组 封装 接口 当设计一个新的包时，新的Go程序员总是通过创建一个接口的集合开始和后面定义满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制(§6.6)来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。 当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好好方式。 因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法（经常和io.Writer或 fmt.Stringer一样只有一个）的更小的接口。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西） Goroutines和Channels 函数 函数声明 递归 多返回值 错误 函数值 匿名函数 可变参数 Deferred 函数 Panic 异常 一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程，在第8章会详细介绍）中被延迟的函数（defer 机制） Recover 捕获异常 方法 方法声明 基于指针对象的方法 通过嵌入结构体来扩展类型 方法值和方法表达式 Bit数组 封装 接口 当设计一个新的包时，新的Go程序员总是通过创建一个接口的集合开始和后面定义满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制(§6.6)来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。 当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好好方式。 因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法（经常和io.Writer或 fmt.Stringer一样只有一个）的更小的接口。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西） 深入理解interface Go语言的主要设计者之一罗布·派克（ Rob Pike）曾经说过，如果只能选择一个Go语言的特 性移植到其他语言中，他会选择接口。可见接口在golang中的地位，及其对gloang这门语言所带来的活力。 Q: golang中的interface是什么? A: 接口相当于是一份契约，它规定了一个对象所能提供的一组操作。要理解golang中接口的概念我们最好还是先来看看别的现代语言是如何实现接口的。 C++没有提供interface这样的关键字，它通过纯虚基类实现接口，而java则通过interface关键字声明接口。它们有个共同特征就是一个类要实现该接口必须进行显示的声明，如下是java方式： interface IFoo { void Bar(); } class Foo implements IFoo { void Bar(){} } 这种必须明确声明自己实现了 某个接口的方式我们称为侵入式接口。关于侵入式接口的坏处我们这里就不再详细讨论，看java庞大的继承体系及其繁复的接口类型我们就可以窥之一二了。 golang则采取了完全不同的设计理念，在Go语言中，一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口， 例如： type IWriter interface { Write(buf [] byte) (n int, err error) } type File struct { // ... } func (f *File) Write(buf [] byte) (n int, err error) { // ... } 非侵入式接口一个很重要的好处就是去掉了繁杂的继承体系，我们看许大神在《go语言编程》一书中作的总结： 其一， Go语言的标准库，再也不需要绘制类库的继承树图。你一定见过不少C++、 Java、 C# 类库的继承树图。这里给个Java继承树图： http://docs.oracle.com/javase/1.4.2/docs/api/overview-tree.html 在Go中，类的继承树并无意义，你只需要知道这个类实现了哪些方法，每个方法是啥含义就足够了。 其二，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才 合理。接口由使用方按需定义，而不用事前规划。 其三，不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦 合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。 如果仔细研究golang中的结构，学C++的同学可能会发现，golang中关于接口的概念很似有点像C++中的Concept，不知道concept的同学可以参看刘未鹏的《C++0x漫谈》系列之：Concept, Concept! 。c++用模板来达到这样的效果，不管你使用什么类型来实例化，只要满足该模板所对应的一组操作就可以正常实例化，否则则会编译不通过。不同于C++的模板在可以完全在编译时检查，golang在大多数情况下只能在运行时进行接口查询，关于接口查询的详细情况我们稍后再解释。 另外，如果有同学之前了解过Qt，则很容易的发现这种非侵入式接口的另一个好处，Qt里面一个重要的特性就是信号与槽，它实现了监听者与接收者之间的解耦，它所用的方式实际上是qt的预处理生成静态的连接代码。而如果使用golang来实现这套机制就简直在方便了，不需要预先生成代码的方式，监听者与接收者之间的解耦本身就是golang的自然表现。 golang中的interface在面向对象思想中所扮演的角色 golang不支持完整的面向对象思想，它没有继承，多态则完全依赖接口实现。golang只能模拟继承，其本质是组合，只不过golang语言为我们提供了一些语法糖使其看起来达到了继承的效果。面向对象中一个很重要的基本原则--里氏代换原则(Liskov Substitution Principle LSP)在这里就行不通了，习惯面向对象语言的同学可能会有些不适应，当你将一个父类的指针指向子类的对象时，golang会毫不吝啬的抛出一个编译错误。 golang的设计理念是大道至简，传统的继承概念在golang中已经显得不是那么必要，golang通过接口去实现多态，下面我们看一个例子，看看golang是如何实现依赖倒置原则的，先看C++的实现： struct IPizzaCooker { virtual void Prepare(Pizza*) = 0; virtual void Bake(Pizza*) = 0; virtual void Cut(Pizza*) = 0; } struct PizzaDefaultCooker : public IPizzaCooker { Pizza* CookOnePizza() { Pizza* p = new Pizza(); Prepare(p); Bake(p); Cut(p); return p; } virtual void Prepare(Pizza*) { //....default prepare pizza } virtual void Bake(Pizza*) { //....default bake pizza } virtual void Cut(Pizza*) { //....default cut pizza } } struct MyPizzaCooker : public PizzaDefaultCooker { virtual void Bake(Pizza*) { //....bake pizza use my style } } int main() { MyPizzaCooker cooker; Pizza* p = cooker.CookOnePizza(); //.... return 0; } 本例子很简单，就是通过一个做pizza的类烹饪一个新pizza，烹饪的流程在父类中实现CookOnePizza，子类重写了Bake方法。下面我们看看golang中是如何实现这个例子的： type IPizzaCooker interface { Prepare(*Pizza) Bake(*Pizza) Cut(*Pizza) } func cookOnePizza(ipc IPizzaCooker) *Pizza { p := new(Pizza) ipc.Prepare(p) ipc.Bake(p) ipc.Cut(p) return p } type PizzaDefaultCooker struct { } func (this *PizzaDefaultCooker) CookOnePizza() *Pizza { return cookOnePizza(this) } func (this *PizzaDefaultCooker) Prepare(*Pizza) { //....default prepare pizza } func (this *PizzaDefaultCooker) Bake(*Pizza) { //....default bake pizza } func (this *PizzaDefaultCooker) Cut(*Pizza) { //....default cut pizza } type MyPizzaCooker struct { PizzaDefaultCooker } func (this *MyPizzaCooker) CookOnePizza() *Pizza { return cookOnePizza(this) } func (this *MyPizzaCooker) Bake(*Pizza) { //....bake pizza use my style } func main() { var cooker MyPizzaCooker p := cooker.CookOnePizza() //.... } 由于golang的多态必须借助接口来实现，这实际上已不是严格意义上的依赖倒置了，在这个例子中golang显得有些笨拙，它其实完全可以有更优雅的实现方案，举这个例子只是为了给大家介绍多态在golang中的实现方式，以及所谓模拟继承并不等价于面向对象中的继承关系。 interface的内存布局 了解interface的内存结构是非常有必要的，只有了解了这一点，我们才能进一步分析诸如类型断言等情况的效率问题。先看一个例子： type Stringer interface { String() string } type Binary uint64 func (i Binary) String() string { return strconv.Uitob64(i.Get(), 2) } func (i Binary) Get() uint64 { return uint64(i) } func main() { b := Binary{} s := Stringer(b) fmt.Print(s.String()) } interface在内存上实际由两个成员组成，如下图，tab指向虚表，data则指向实际引用的数据。虚表描绘了实际的类型信息及该接口所需要的方法集 观察itable的结构，首先是描述type信息的一些元数据，然后是满足Stringger接口的函数指针列表（注意，这里不是实际类型Binary的函数指针集哦）。因此我们如果通过接口进行函数调用，实际的操作其实就是s.tab->fun0。是不是和C++的虚表很像？接下来我们要看看golang的虚表和C++的虚表区别在哪里。 先看C++，它为每种类型创建了一个方法集，而它的虚表实际上就是这个方法集本身或是它的一部分而已，当面临多继承时（或者叫实现多个接口时，这是很常见的），C++对象结构里就会存在多个虚表指针，每个虚表指针指向该方法集的不同部分，因此，C++方法集里面函数指针有严格的顺序。许多C++新手在面对多继承时就变得蛋疼菊紧了，因为它的这种设计方式，为了保证其虚表能够正常工作，C++引入了很多概念，什么虚继承啊，接口函数同名问题啊，同一个接口在不同的层次上被继承多次的问题啊等等……就是老手也很容易因疏忽而写出问题代码出来。 我们再来看golang的实现方式，同C++一样，golang也为每种类型创建了一个方法集，不同的是接口的虚表是在运行时专门生成的。可能细心的同学能够发现为什么要在运行时生成虚表。因为太多了，每一种接口类型和所有满足其接口的实体类型的组合就是其可能的虚表数量，实际上其中的大部分是不需要的，因此golang选择在运行时生成它，例如，当例子中当首次遇见s := Stringer(b)这样的语句时，golang会生成Stringer接口对应于Binary类型的虚表，并将其缓存。 理解了golang的内存结构，再来分析诸如类型断言等情况的效率问题就很容易了，当判定一种类型是否满足某个接口时，golang使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型满足该接口。例如某类型有m个方法，某接口有n个方法，则很容易知道这种判定的时间复杂度为O(mXn)，不过可以使用预先排序的方式进行优化，实际的时间复杂度为O(m+n)。 因为几乎任何东西都可加以方法，几乎任何东西都可满足某界面。一个展示的例子是 http 包定义的 Handler 界面。任何物件实现了Handler 都可服务 HTTP 请求。 type Handler interface { ServeHTTP(*Conn, *Request) } ResponseWriter 本身是个界面，它提供一些可访问的方法来返回客户的请求。这些方法包括标准的 Write 方法。因此 http.ResponseWriter 可用在 io.Writer 可以使用的地方。Request 是个结构，包含客户请求的一个解析过的表示。 为求简短，我们忽略 POST 并假定所有 HTTP 请求都是 GET；此简化不会影响经手者的设置。下面一个小而全的经手者实现了网页访问次数的计数。 // Simple counter server. type Counter struct { n int } func (ctr *Counter) ServeHTTP(c *http.Conn, req *http.Request) { ctr.n++ fmt.Fprintf(c, \"counter = %d\\n\", ctr.n) } （注意 Fprintf 怎样打印到 http.ResponseWriter）。作为参考，这里是怎样把服务者加在一个 URL 树的节点上。 import \"http\" ... ctr := new(Counter) http.Handle(\"/counter\", ctr) 可是为何把 Counter 作为结构呢？一个整数能够了。（接受者需是指针，使增量带回调用者）。 // Simpler counter server. type Counter int func (ctr *Counter) ServeHTTP(c *http.Conn, req *http.Request) { *ctr++ fmt.Fprintf(c, \"counter = %d\\n\", *ctr) } 当某页被访问时怎样通知你的程序更新某些内部状态呢？给网页贴个信道。 // A channel that sends a notification on each visit. // (Probably want the channel to be buffered.) type Chan chan *http.Request func (ch Chan) ServeHTTP(c *http.Conn, req *http.Request) { ch 最后，让我们在 /args 显示启动服务器时的参量。写个打印参量的函数很容易： func ArgServer() { for i, s := range os.Args { fmt.Println(s) } } 怎样把它变成 HTTP 服务器呢？我们可以把 ArgServer 作为某个类型的方法再忽略其值，也有更干净的做法。既然我们可以给任意非指针和界面的类型定义方法，我们可以给函数写个方法。http 包里有如下代码： // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers. If f is a function // with the appropriate signature, HandlerFunc(f) is a // Handler object that calls f. type HandlerFunc func(*Conn, *Request) // ServeHTTP calls f(c, req). func (f HandlerFunc) ServeHTTP(c *Conn, req *Request) { f(c, req) } HandlerFunc 是个带 ServeHTTP 方法的类型， 所以此类的值都可以服务 HTTP 请求。我们来看看此方法的实现：接受者是个函数，f，方法调用 f 。看起来很怪，但和，比如，接受者是信道，而方法发送到 此信道，没什么不同。 要把 ArgServer 变为 HTTP 服务器， 我们首先改成正确的签名： // Argument server. func ArgServer(c *http.Conn, req *http.Request) { for i, s := range os.Args { fmt.Fprintln(c, s) } } ArgServer 现在和 HandlerFunc 有同样的签名，就可以转成此类使用其方法，就像我们把 Sequence 转为 IntArray 来使用 IntArray.Sort 一样。设置代码很简短： http.Handle(\"/args\", http.HandlerFunc(ArgServer)) 当有人访问 /args 页时，此页的经手者有值 ArgServer 和类型HandlerFunc。HTTP 服务器启动此类型的 ServeHTTP 方法，用ArgServer 作为接受者，反过来调用 ArgServer （通过启动handlerFunc.ServeHTTP 的 f(w, req) 。）参量被显示出来。 此节中我们从一个结构，整数，信道和一个函数制造出一个 HTTP 服务器，全赖于界面就是一套方法，可定义在（几乎）任何类型上。 Goroutines和Channels 基于共享变量的并发 包和工具 工具 测试 go test 反射 为何需要反射? 有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候还这些类型可能还不存在，各种情况都有可能。 reflect.Type和reflect.Value 反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 它是一个接口, 有许多方法来区分类型和检查它们的组件, 例如一个结构体的成员或一个函数的参数等. 唯一能反映 reflect.Type 实现的是接口的类型描述信息, 同样的实体标识了动态类型的接口值. 因为 reflect.TypeOf 返回的是一个动态类型的接口值, 它总是返回具体的类型. 因此, 下面的代码将打印 \"*os.File\" 而不是 \"io.Writer\". 稍后, 我们将看到 reflect.Type 是具有识别接口类型的表达方式功能的.var w io.Writer = os.Stdout fmt.Println(reflect.TypeOf(w)) // \"*os.File\" 要注意的是 reflect.Type 接口是满足 fmt.Stringer 接口的. 因为打印动态类型值对于调试和日志是有帮助的, fmt.Printf 提供了一个简短的 %T 标志参数, 内部使用 reflect.TypeOf 的结果输出:fmt.Printf(\"%T\\n\", 3) // \"int\" 逆操作是调用 reflect.ValueOf 对应的 reflect.Value.Interface 方法. 它返回一个 interface{} 类型表示 reflect.Value 对应类型的具体值:v := reflect.ValueOf(3) // a reflect.Value x := v.Interface() // an interface{} i := x.(int) // an int fmt.Printf(\"%d\\n\", i) // \"3\" "},"notes/groupcache.html":{"url":"notes/groupcache.html","title":"GroupCache","keywords":"","body":"GroupCache groupcache 是 Brad Fitzpatrick 最新的作品，目标在于取代一部分memcached的功能。以官方的说明是：groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases. 另外一篇介绍文是「Playing With Groupcache」。跟memcached 差异最大的地方在于「没有更改与删除的功能」，一旦写进去后就不会变动。在放弃update/delete 的特性后，换来的是： Cluster 的能力。 处理热点的能力。 以往在memcached server 之间是没有交集的，在groupcache 则是cluster 起来。另外以前在memcached 会因为同时存取同一个key 而造成single CPU overloading 的问题，在groupcache 则透过auto-mirror 机制解决。参考：Go 语言编写的缓存及缓存过滤库：groupcache 。其中groupcache与memcached最大的区别是不需要启动额外的服务。groupcache作为lib库缓存数据，不需要单独开启服务器，减少了服务器额外维护的代价。groupcache也常被推荐为适合Golang初学者分析的代码段，这几天我也抽空分析了一下具体的实现，并结合Play With Groupcach简单的测试了GroupCache，实现的基本结构如下所示： 该软件结构图实现了一种只读型静态网站的分布式实现。主要包括三个服务器，其中DB Server是数据库，主要对外提供数据，在实际的场景中可以是NoSql数据库也可能是关系数据库。可对该数据库进行插入、新增数据。缓存服务器，分为前端和GroupCache Server，实际上将Cache Server包含在了业务代码中，其中前端是提供操作的相关接口，而后端部分通常作为业务服务器的一部分，缓存数据可直接被服务器使用。Cli部分主要是用于操作数据量和groupcache server交互。这部分代码可参考groupcache-db-experiment 。 基本过程如下所示: 首先创建一个GroupCache的HTTPool, peers。 创建Group对象， 设置该Group Cache的大小，数据实际获取的方法，其中的 groupcache.GetterFunc对应着实际从源头加载数据的方法，比如从数据库中获取、从文件中获取等。这也是必须的。groupcache.GetterFunc实际上是groupcache.Getter的接口实例。 设置对端GroupCache的地址信息。peers.Set(url1, url2, ...) 启动GroupCache的Http服务。在http.ListenAndServe(\"xxxx\", http.HandlerFunc(peers.ServeHTTP)) 要获取数据只需要通过创建的Group对象来获取即可。group.Get(xxx)。 "},"notes/synchronization.html":{"url":"notes/synchronization.html","title":"同步","keywords":"","body":"同步(Synchronization) 初始化 程序的初始化在一个独立的goroutine中执行。在初始化过程中创建的goroutine将在 第一个用于初始化goroutine执行完成后启动。 如果包p导入了包q，包q的init初始化函数将在包p的初始化之前执行。 程序的入口函数 main.main 则是在所有的 init 函数执行完成 之后启动。 在任意init函数中新创建的goroutines，将在所有的init 函数完成后执行。 goroutine的创建 用于启动goroutine的go语句在goroutine之前运行。 var a string func f() { print(a) } func hello() { a = \"hello, world\" go f() } 调用hello函数，会在某个时刻打印“hello, world”（有可能是在hello函数返回之后）。 Channel communication 管道通信 用管道通信是两个goroutines之间同步的主要方法。在管道上执行的发送操作会关联到该管道的 接收操作，这通常对应goroutines。 管道上的发送操作发生在管道的接收完成之前（happens before）。 ``` var c = make(chan int, 10) var a string func f() { a = \"hello, world\" c func main() { go f() 可以确保会输出\"hello, world\"。因为，a的赋值发生在向管道 c发送数据之前，而管道的发送操作在管道接收完成之前发生。 因此，在print 的时候，a已经被赋值。 从一个unbuffered管道接收数据在向管道发送数据完成之前发送。 package main var c = make(chan int) var a string func f() { a = \"hello, world\" func main() { go f() c 同样可以确保输出“hello, world”。因为，a的赋值在从管道接收数据 前发生，而从管道接收数据操作在向unbuffered 管道发送完成之前发生。所以，在print 的时候，a已经被赋值。 如果用的是缓冲管道（如 c = make(chan int, 1) ），将不能保证输出 “hello, world”结果（可能会是空字符串， 但肯定不会是他未知的字符串， 或导致程序崩溃）。 ### 锁 包sync实现了两种类型的锁： sync.Mutex 和 sync.RWMutex。 对于任意 sync.Mutex 或 sync.RWMutex 变量l。 如果 n var l sync.Mutex var a string func f() { a = \"hello, world\" l.Unlock() } func main() { l.Lock() go f() l.Lock() print(a) } 可以确保输出“hello, world”结果。因为，第一次 l.Unlock() 调用（在f函数中）在第二次 l.Lock() 调用 （在main 函数中）返回之前发生，也就是在 print 函数调用之前发生。 对于任何呼叫到一个sync.RWMutex变数l l.RLock，有一个n使得l.RLock第n个呼叫l.Unlock后发生（返回）和n +1'th之前的匹配l.RUnlock发生调用l.Lock。 包sync提供了一个在多个goroutines中进行初始化的方法。多个goroutines可以 通过 once.Do(f) 方式调用f函数。 但是，f函数 只会被执行一次，其他的调用将被阻塞直到唯一执行的f()返回。 once.Do(f) 中唯一执行的f()发生在所有的 once.Do(f) 返回之前。 var once sync.Once var a string func setup() { a = \"hello, world\" } func doprint() { once.Do(setup) print(a) } func twoprint() { go doprint() go doprint() } > 调用twoprint会输出“hello, world”两次。第一次twoprint 函数会运行setup唯一一次。 ## ***错误的同步方式*** 注意：变量读操作虽然可以侦测到变量的写操作，但是并不能保证对变量的读操作就一定发生在写操作之后。 package main var a, b int func f() { a = 1 b = 2 } func g() { print(b) print(a) } func main() { go f() g() } 函数g可能输出2，也可能输出0。 这种情形使得我们必须回避一些看似合理的用法。 这里用重复检测的方法来代替同步。在例子中，twoprint函数可能得到错误的值： package main import ( \"sync\" \"time\" ) var once sync.Once var a string var done bool func setup() { a = \"hello, world\" done = true } func doprint() { if !done { once.Do(setup) } print(a) } func twoprint() { go doprint() go doprint() } func main() { twoprint() time.Sleep(8000) } 在doprint函数中，写done暗示已经给a赋值了。 但是没有办法给出保证，函数可能输出空的值（在2个goroutines中同时执行到测试语句）。 另一个错误陷阱是忙等待： package main var a string var done bool func setup() { a = \"hello, world\" done = true } func main() { go setup() for !done { } print(a) } 我们没有办法保证在main中看到了done值被修改的同时也 能看到a被修改，因此程序可能输出空字符串。 更坏的结果是，main 函数可能永远不知道done被修改，因为在两个线程之间没有同步操作，这样main 函数永远不能返回。 下面的用法本质上也是同样的问题. package main type T struct { msg string } var g *T func setup() { t := new(T) t.msg = \"hello, world\" g = t } func main() { go setup() for g == nil { } print(g.msg) } ``` 即使main观察到了 g != nil 条件并且退出了循环，但是任何然 不能保证它看到了g.msg的初始化之后的结果。 在这些例子中，只有一种解决方法：用显示的同步。 "},"notes/docker.html":{"url":"notes/docker.html","title":"Docker","keywords":"","body":"Docker常用命令 查看docker信息（version、info） 查看docker版本 $docker version 显示docker系统的信息 $docker info 对image的操作（search、pull、images、rmi、history） 检索image $docker search image_name 下载image $docker pull image_name 列出镜像列表; -a, --all=false 显示所有镜像; --no-trunc=false 不要截断输出; -q, --quiet=false 仅显示数字ID $docker images 删除一个或者多个镜像; -f, --force=false 强行; --no-prune=false 不要删除未标记的父级 $docker rmi image_name 显示一个镜像的历史; --no-trunc=false 不要截断输出; -q, --quiet=false 仅显示数字ID $docker history image_name 启动容器（run） docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。 在容器中运行\"echo\"命令，输出\"hello word\" $docker run image_name echo \"hello word\" 交互式进入容器中 $docker run -i -t image_name /bin/bash 挂载本地目录,实现文件共享 $docker run -it -v _path:docker_path image_name /bin/bash 在容器中安装新的程序 $docker run image_name apt-get install -y app_name 注意： 在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。 查看容器（ps） 列出当前所有正在运行的container $docker ps 列出所有的container$docker ps -a 列出最近一次启动的container $docker ps -l 保存对容器的修改（commit） 当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。 保存对容器的修改; -a, --author=\"\" 作者; -m, --message=\"\" 提交消息 $docker commit ID new_image_name 注意： image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach） 删除所有容器$docker rm `docker ps -a -q` 删除单个容器; -f, --force=false; -l, --link=false 删除指定的链接，而不是基础容器; -v, --volumes=false 删除与容器关联的卷 $docker rm Name/ID 停止、启动、杀死一个容器 $docker stop Name/ID $docker start Name/ID $docker kill Name/ID 从一个容器中取日志; -f, --follow=false 按照日志输出; -t, --timestamps=false 显示时间戳 $docker logs Name/ID 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的 $docker diff Name/ID 显示一个运行的容器里面的进程信息 $docker top Name/ID 从容器里面拷贝文件/目录到本地一个路径 $docker cp Name:/container_path to_path $docker cp ID:/container_path to_path 重启一个正在运行的容器; -t, --time=10 尝试在停止容器之前停止的秒数, 默认=10 $docker restart Name/ID 附加到一个运行的容器上面; --no-stdin=false 不要附加标准输入(stdin); --sig-proxy=true 将所有接收到的信号代理给进程 $docker attach ID 注意： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。 保存和加载镜像（save、load） 当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。 保存镜像到一个tar包; -o, --output=\"\" 写入文件 $docker save image_name -o file_path 加载一个tar包格式的镜像; -i, --input=\"\" 从tar存档文件读取 $docker load -i file_path 机器a $docker save image_name > /home/save.tar 使用scp将save.tar拷到机器b上，然后： $docker load 登录registry server（login） 登陆registry server; -e, --email=\"\" 电子邮件; -p, --password=\"\" 密码; -u, --username=\"\" 用户名 $docker login 发布image（push） 发布docker镜像 $docker push new_image_name 根据Dockerfile 构建出一个容器 build --no-cache=false 在构建映像时不要使用缓存 -q, --quiet=false 抑制由容器生成的详细输出 --rm=true 成功构建后删除中间容器 -t, --tag=\"\" 在成功的情况下应用于生成的图像的存储库名称（以及可选的标记） $docker build -t image_name Dockerfile_path Docker源码分析 init函数的执行。在Golang中init函数的特性如下： init函数用于程序执行前包的初始化工作，比如初始化变量等； 每个包可以有多个init函数； 包的每一个源文件也可以有多个init函数； 同一个包内的init函数的执行顺序没有明确的定义； 不同包的init函数按照包导入的依赖关系决定初始化的顺序； init函数不能被调用，而是在main函数调用前自动被调用。 os.Setenv(\"DEBUG\", \"1\") 创建系统环境变量 Docker-github Docker源码分析 孙宏亮 -infoQ Docker源码分析（一）：Docker架构 Docker源码分析（二）：Docker Client创建与命令执行 Docker源码分析（三）：Docker Daemon启动 Docker源码分析（四）：Docker Daemon之NewDaemon实现 Docker源码分析（五）：Docker Server的创建 Docker源码分析（六）：Docker Daemon网络 Docker源码分析（七）：Docker Container网络 （上） Docker源码分析（八）：Docker Container网络 （下） Docker源码分析（九）：Docker镜像 Docker源码分析（十）：Docker镜像下载 Docker源码分析（十一）：镜像存储 Docker三年回顾：梦想依在，人生正当年 超大规模容器调度系统的设计与实现 图书 Docker入门实战 "},"notes/gui.html":{"url":"notes/gui.html","title":"GUI","keywords":"","body":"GUI GO语言的图形界面Walk https://github.com/lxn/walk http://www.cnblogs.com/Darksun/p/4470617.html "},"blog/":{"url":"blog/","title":"博客","keywords":"","body":"博客 GO 开发者对 GO 初学者的建议 原文 注：原文地址为 Advise from Go developers to Go programming newbies 以促进 India 的 go 编程作为 GopherConIndia 承诺的一部分。我们采访了 40 位 Gophers（一个 Gopher 代表一个 GO 项目或是任何地方的 GO 程序员），得到了他们关于 GO 的意见。从 2014 年的八月到十一月，我们将每个星期发表两篇采访稿。 如果你正好刚刚开始 go 编程，他们对于我们一些问题的答案可能会对你有非常有用。看看这些。 应该做： 通读 the Go standard library 和 Effective Go，为了学习 GO 的规范，Effective Go 是被高度推荐的，尤其是如果你有其他语言的背景。 在 Go tour 上做练习 看完语言参考 练习 Go by Example，而不仅仅是复制粘贴！ 坚持编写 GO 代码，在几周内你将会在这门语言上变得高效 理解接口的功能，他们是 GO 最大的礼物之一，可能比 channels 和 goroutines 还重要。这个关于接口的文章 article on interfaces 和 Andrew Gerrand 在 GopherCon 2014 上的 keynote 接口的描述 会对你非常有帮助。 抛弃你的 OO 的思想包袱，如果你来自于其他语言，比如动态语言 Python 或是 Ruby，或者是一个编译型语言如 Java 或 C#。GO 是一个面向对象的语言，但是它不是一个基于 class 的语言和不支持继承。 了解继承从 GO 语言中移除了。实践组合的用法而不是继承的机会显现了，并且纠结于继承只会导致你沮丧 不要以其他语言的风格编写 GO 寻找更加有经验的 Gophers，他们能帮助你 review 代码片段和给你反馈。在 GO 社区能得到真正的支持和帮助 用 GO 实现你想法中的一个项目或是找到一个项目来工作。然后随着你学习的更多，不断重构你的应用。利用邮件列表和参加 Gopher Academy Slack group 来见其他的 Gophers 来得到帮助。Dave Cheney 的博客和 GoingGo 的博客也是一个非常好的开始 不要等待泛型和函数式被添加进语言；屏住呼吸并学习爱上我们在今天拥有的这门语言 注：私人添加，可以订阅 Newspaper.io 的 Golang Daily，以及 @ASTA谢 的 《Go Web 编程》 【作者也出了实体书，大家可以购买】和 订阅 Golang Ask News，社区 http://golanghome.com/，@无闻Unknown 的 《Go编程基础》，《Go Web基础》 和 《Go名库讲解》 给 go 初学者分享的一些问题 对于任何人来说学习一门新语言可能都是令人挫折的。GO 社区是不可置信的活跃，你不是孤单的。利用所有的文档，博客，本地的 Meetups 和用户组，比如 Slack。不要害怕问问题和参与 如果你对 GO 感兴趣，使用它的一侧涉足，或是专业的使用它，如果本地有 Go meetup，考虑参与。如果你有货，考虑去分享它 如果你有计划旅行，并且有能力，努力去访问 GO 社区目的地 来访的用户群体是个证明这个社区有众多的用户，支持者和雇员的途径 不要浪费时间去和其他语言比较，如果你喜欢 GO，就爱上他并且去使用它 接受 Go 的文化和 GO 做事情的方式。你的代码会感谢你，如果你这样做了，你会得到很多 不要冲动的引入依赖 简单是 GO 最重要的特征。避免过分设计，使用简单的代码片段而不是单一的庞大的代码库 从其他语言移植库到 GO 是一个很好的做法，它允许你剥离他人的代码并且以符合 GO 语言的方式粘合起来。 注：How do you see the market for Go Programmers in the work place? What is the future for Go 这部分不翻译，请读者自己看 GO程序员进化史 来自贝尔实验室的两位大牛罗布·派克,肯·汤普逊与Google的罗伯特·格瑞史莫,2007年开始设计的一种编译型，可平行化，并具有垃圾回收功能的编程语言。 罗布·派克（Rob Pike）1980年奥运会射箭的银牌得主(超级厉害了) C语言之父肯·汤普逊(Kenneth Lane Thompson) 罗伯特·格瑞史莫（Robert Griesemer）曾在Java编译器方面的工作 Ian Lance TaylorGithub Russ Cox Go语言是基于Inferno操作系统所开发的。 Go语言于2009年11月有Google正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后追加Windows系统下的实现。 Go语言的特点在wiki里有介绍 Go程序可以从3行到数百万行，它被写入到一个或多个文本文件扩展名“.go”;例如，hello.go。你可以用“vi”，“vim”或任何其他文本编辑器来编写Go程序到到文件中。 go build hello.go可以编译生成一个二进制的hello linux没有后缀 go run hello.go 可以直接执行 Francesc 是 Go 核心团队的一员, 是提倡 Google Cloud 平台的开发者. 他是一个编程语言的爱好者, Google的技术指导大师, Go tour的创造者之一. 这个讨论的灵感来自于另一个 Raquel Vélez 在 JSConf. Slides 的讨论。 Sourcegraph 是下一代编程协作工具, 用于搜索, 探索, 和审查代码. 我们参加GopherCon India 来分享我们是怎样使用 Go 并学习别人是怎样使用它的, 对配合liveblog的这次讨论我们深感荣幸。 作为Go团队的开发者之一，Francesc可能比世界上其他人接触到的Go语言程序员都要多。正因为有了这样的有利条件，他把Go语言的学习过程划分为5个阶段。 这些阶段对于其他语言的学习也是成立的。理解自己处于哪个阶段，可以帮助你找到提高自己的最有效的方法，也可以避免每个阶段学习过程中的常见陷阱。 编者按：这篇文章对于每一个学习阶段都给出了交互式的代码片段。点击函数名你就可以跳到具体的函数定义，方便进行深入的研究。请看下文。 这里是GO程序员的五个进化阶段: 第一阶段 (菜逼): 刚刚学习了这门语言。 已经通过一些教程或者培训班了解基本的语法，可以写短的代码片段。 第二阶段 (探索者): 可以写一个完整的程序，但不懂一些更高级的语言特征，比如“channels”。还没有使用GO写一个大项目。 第三阶段 (大手): 你能熟练的使用Go, 能够用GO去解决，生产环境中一个具体和完整的问题。已经形成了一套自己的惯用法和常用代码库。在你的编码方案中Go是一个非常好用的工具。 第四阶段 (大神): 绝逼清楚Go语言的设计选择和背后的动机。能理解的简洁和可组合性哲学。 第五阶段 (布道师): 积极地与他人分享关于Go语言知识和你对Go语言的理解。在各种合适的场所发出自己的声音, 参与邮件列表、建立QQ群、做专题报告。成为一个布道者不见得是一个完全独立的阶段，这个角色可以在上述的任何一个阶段中。第一阶段: 菜逼 菜鸟在这个阶段使用Go去创建一些小项目或者玩具项目。他们应该会利用到Go tour, Go playground, Go文档, 和邮件列表(golang-nuts).func main() { fmt.Println(stringutil.Reverse(\"!selpmaxe oG ,olleH\"))} 这是Go语言写的简单例子，这个代码段来自golang/example代码库里面的 hello.go。点击就可以查看完整代码撸。 一项重要的技能，新人应该试着学习如何正确提问。很多新人在邮件列表里面这样说“嘿，这报错了”，这并没有提供足够的信息，让别人能理解并帮助他们解决问题。别人看到的是一个粘贴了几百行的代码的帖子，并没有花费精力来重点说明所遇到的问题。 所以, 应该尽量避免直接粘贴代码到论坛。而应该使用可以编辑并且可以在浏览器中直接运行的Go playground的“分享”按钮链接到代码片段。第二阶段：探索者 探索者已经可以使用Go写一些小的软件，但有时仍然会有些迷茫。他们可能不完全明白怎么使用Go的高级特性，比如通道。虽然他们还有很多东西要学习，但已掌握的足够做一些有用的事情了！他们开始对Go的潜能有感觉了，并对它们能使用Go创建的东西感到兴奋。 在探索阶段通常会经历两个步骤。第一，膨胀的预期达到顶点，你觉得可以用Go做所有的事情，但还并不能明白或领悟到Go的真谛。你大概会用所熟悉的语言的模式和惯用语来写Go代码，但对于什么是地道的Go，还没有比较强烈的感觉。你开始尝试着手干这样的事情--“迁移架构X，从Y语言到Go语言”。 到达预期膨胀的顶点之后，你会遇到理想幻灭的低谷。你开始想念语言Y的特性X，此时你还没有完全的掌握地道的Go。你还在用其他编程语言的风格来写Go语言的程序，你甚至开始觉得沮丧。你可能在大量使用reflect和unsafe这两个包，但这不是地道的Go。地道的Go不会使用那些魔法一样的东西。 这个探索阶段产生的项目的一个很好的例子就是Martini Web框架。Martini是一个Go语言的早期Web框架，它从Ruby的Web框架当中吸收了很多思想（比如依赖注入）。最初，这个框架在社区中引起了强烈的反响，但是它逐渐在性能和可调试性上受到了一些批评。Martini框架的作者Jeremy Saenz积极响应这些来自Go社区的反馈，写了一个更加符合Go语言规范的库Negroni ```golang func (m *Martini) RunOnAddr(addr string) { // TODO: Should probably be implemented using a new instance of http.Server in place of // calling http.ListenAndServer directly, so that it could be stored in the martini struct for later use. // This would also allow to improve testing when a custom host and port are passed. logger := m.Injector.Get(reflect.TypeOf(m.logger)).Interface().(*log.Logger) logger.Printf(\"listening on %s (%s)\\n\", addr, Env) logger.Fatalln(http.ListenAndServe(addr, m)) } 来自Martini框架的交互式代码片段，它是不地道的Go的例子。注意用反射包实现的依赖注入 ```golang func TestNegroniServeHTTP(t *testing.T) { result := \"\" response := httptest.NewRecorder() n := New() n.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) { result += \"foo\" next(rw, r) result += \"ban\" })) n.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) { result += \"bar\" next(rw, r) result += \"baz\" })) n.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) { result += \"bat\" rw.WriteHeader(http.StatusBadRequest) })) n.ServeHTTP(response, (*http.Request)(nil)) expect(t, result, \"foobarbatbazban\") expect(t, response.Code, http.StatusBadRequest) } 来自Negroni库的交互式代码片段，它是地道的Go的例子 其他语言在提供一些核心功能，比如HTTP处理的时候，往往需要依赖第三方库。但是Go语言在这一点上很不同，它的标准库非常强大。如果你认为Go标准库没有强大到可以做你想做的事情，那么我说你错了。Go语言标准库难以置信的强大，值得你花时间阅读它的代码，学习它实现的模式。 func (srv *Server) ListenAndServe() error { addr := srv.Addr if addr == \"\" { addr = \":http\" } ln, err := net.Listen(\"tcp\", addr) if err != nil { return err } return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)}) } Go标准库中的ListenAndServe函数片段。如果你写过Go程序，你可能已经调用过这个函数很多次了，但是你曾经花时间看过它的实现么？去点击上面的代码片段吧。 幻灭的低谷中的幻灭感来自于这样的事实：你还在用其他语言的模式来想问题，而且你还没有完全探索过Go能提供给你什么。下面是一些好玩的事情，你可以做一下来打破困境，进一步探索这门语言中好玩的事。 go generate 现在来看看go generate。go generate是一个你可以用来自动自成Go代码的命令。你可以结合例如jsonenums(一个用于为枚举类型自动生成JSON编组样板代码的类库)这样的元编程来使用go generate快速自动实现重复乏味代码的编写。在Go标准类库里面已经有大量可以用于解析AST的接口，而AST使得编写元编程工具更简单，更容易。在会议上，有另外两次讨论（Go语言中的元编程实践和拥抱标准类库）谈及到了这一点。 func main() { flag.Parse() if len(*typeNames) == 0 { log.Fatalf(\"the flag -type must be set\") } types := strings.Split(*typeNames, \",\") // Only one directory at a time can be processed, and the default is \".\". dir := \".\" if args := flag.Args(); len(args) == 1 { dir = args[0] } else if len(args) > 1 { log.Fatalf(\"only one directory at a time\") } pkg, err := parser.ParsePackage(dir, *outputSuffix+\".go\") if err != nil { log.Fatalf(\"parsing package: %v\", err) } var analysis = struct { Command string PackageName string TypesAndValues map[string][]string }{ Command: strings.Join(os.Args[1:], \" \"), PackageName: pkg.Name, TypesAndValues: make(map[string][]string), } // Run generate for each type. for _, typeName := range types { values, err := pkg.ValuesOfType(typeName) if err != nil { log.Fatalf(\"finding values for type %v: %v\", typeName, err) } analysis.TypesAndValues[typeName] = values var buf bytes.Buffer if err := generatedTmpl.Execute(&buf, analysis); err != nil { log.Fatalf(\"generating code: %v\", err) } src, err := format.Source(buf.Bytes()) if err != nil { // Should never happen, but can arise when developing this code. // The user can compile the output to see the error. log.Printf(\"warning: internal error: invalid Go generated: %s\", err) log.Printf(\"warning: compile the package to analyze the error\") src = buf.Bytes() } output := strings.ToLower(typeName + *outputSuffix + \".go\") outputPath := filepath.Join(dir, output) if err := ioutil.WriteFile(outputPath, src, 0644); err != nil { log.Fatalf(\"writing output: %s\", err) } } } 一段互动的片段演示了如何编写jsonenums命令。 OpenGL 许多人使用Go作web服务，但是你知道你也可以用Go写出很cool的图形应用吗？查看Go在OpenGL中的捆绑。 func main() { glfw.SetErrorCallback(errorCallback) if !glfw.Init() { panic(\"Can't init glfw!\") } defer glfw.Terminate() window, err := glfw.CreateWindow(Width, Height, Title, nil, nil) if err != nil { panic(err) } window.MakeContextCurrent() glfw.SwapInterval(1) gl.Init() if err := initScene(); err != nil { fmt.Fprintf(os.Stderr, \"init: %s\\n\", err) return } defer destroyScene() for !window.ShouldClose() { drawScene() window.SwapBuffers() glfw.PollEvents() } } 交互式的片段正说明Go的OpenGL捆绑能制作Gopher cube。点击函数或方法名去探索。 黑客马拉松和挑战 你也可以观看挑战和黑客马拉松，类似Gopher Gala和Go Challenge。在过去，来自世界各地的程序员一起挑战一些真实的酷项目，你可以从中获取灵感。 第三阶段: 老手 作为一个老手，这意味着你可以解决很多Go语言中你关心的问题。新的需要解决的问题会带来新的疑问，经过试错，你学会了在这门语言中什么是可以做的，什么是不能做的。此时，你已经对这门语言的习惯和模式有了一个坚实的理解。你可以非常高效地工作，写出可读，文档完善，可维护的代码。 成为老手的一个很好的方法就是在大项目上工作。如果你自己有一个项目的想法，开始动手去做吧（当然你要确定它并不是已经存在了）。大多数人也许并没有一个很大的项目的想法，所以他们可以对已经存在的项目做出贡献。Go语言已经有很多大型项目，而且它们正在被广泛使用，比如Docker, Kubernetes和Go本身。可以看看这个项目列表 func (cli *DockerCli) CmdRestart(args ...string) error { cmd := cli.Subcmd(\"restart\", \"CONTAINER [CONTAINER...]\", \"Restart a running container\", true) nSeconds := cmd.Int([]string{\"t\", \"-time\"}, 10, \"Seconds to wait for stop before killing the container.\") cmd.Require(flag.Min, 1) utils.ParseFlags(cmd, args, true) v := url.Values{} v.Set(\"t\", strconv.Itoa(*nSeconds)) var encounteredError error for _, name := range cmd.Args() { _, _, err := readBody(cli.call(\"POST\", \"/containers/\"+name+\"/restart?\"+v.Encode(), nil, false)) if err != nil { fmt.Fprintf(cli.err, \"%s\\n\", err) encounteredError = fmt.Errorf(\"Error: failed to restart one or more containers\") } else { fmt.Fprintf(cli.out, \"%s\\n\", name) } } return encounteredError } Docker项目的交互式代码片段。点击函数名，开始探索之旅吧。 老手应该对Go生态系统的工具有一个很强的掌握，因为这些工具真的提高生产效率。你应该了解go generate，go vet，go test-race， 和gofmt/goimports/goreturns。你应该使用go fmt，因为它会自动把你的代码按照Go社区的风格标准来格式化。goimports可以做同样的事情，而且还会添加丢失的imports。goretures不光做了前面所说的事情，还可以在返回表达式添加丢失的错误，这是大家都讨厌的地方。 在老手阶段，你一定要开始做code review。code review的意义并不是要修改或者找到错误（那是测试人员做的事情）。code review可以帮助维持统一的编程风格，提高软件的总体质量，还可以在别人的反馈中提高你自己的编程技术。几乎所有的大型开源项目都对每一个提交做code review。 下面是一个从人类的反馈当中学习的例子：Google的Go团队以前都在main函数的外面声明命令行标记。在去年的GopherCon会议上，Francesc遇到了SoundCloud公司的Peter Bourgon（@peterbourgon）。Peter Bourgon说在SoundCloud，他们都在main函数内部声明标记，这样他们不会错误地在外部使用标记。Francesc现在认为这是最佳实践。 第四阶段：专家 作为一个专家，你很好地了解了语言的哲学思想。对于Go语言的特性，你知道何时应该使用，何时不应该使用。例如，Jeremy Saenz在dotGo风暴讨论中谈论到了何时不该使用接口。 func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call { call := new(Call) call.ServiceMethod = serviceMethod call.Args = args call.Reply = reply if done == nil { done = make(chan *Call, 10) // buffered. } else { // If caller passes done != nil, it must arrange that // done has enough buffer for the number of simultaneous // RPCs that will be using that channel. If the channel // is totally unbuffered, it's best not to run at all. if cap(done) == 0 { log.Panic(\"rpc: done channel is unbuffered\") } } call.Done = done client.send(call) return call } 来自标准类库的一小块交互代码片段使用了频道。理解标准类库里面的模式背后的决策原因是成为一个专家必经之路。 但是不要成为只局限于单一语言的专家。跟其他任何语言一样，Go仅仅只是一个工具。你还应该去探索其他语言，并且学习他们的模式和风格。Francesc从他使用Go的经验中找到了编写JavaScript的启发。他还喜欢重点关注于不可变性和致力于避免易变性的Haskell语言，并从中获得了如何编写Go代码的灵感。 第五阶段：布道者 作为一个布道者，你分享自己的知识，传授你学会的和你提出的最佳实践。你可以分享自己对Go喜欢或者不喜欢的地方。全世界各地都有Go会议，找到离你最近的。 你可以在任何一个阶段成为布道者，不要等到你成为这个领域的专家的时候才发出自己的声音。在你学习Go的任何一个阶段，提出问题，结合你的经验给出反馈，不要羞于提出自己不喜欢的地方。你提出的反馈可以帮助社区改善做事情的方法，也可能改变你自己对编程的看法。 func main() { httpAddr := flag.String(\"http\", \"127.0.0.1:3999\", \"HTTP service address (e.g., '127.0.0.1:3999')\") originHost := flag.String(\"orighost\", \"\", \"host component of web origin URL (e.g., 'localhost')\") flag.StringVar(&basePath, \"base\", \"\", \"base path for slide template and static resources\") flag.BoolVar(&present.PlayEnabled, \"play\", true, \"enable playground (permit execution of arbitrary user code)\") nativeClient := flag.Bool(\"nacl\", false, \"use Native Client environment playground (prevents non-Go code execution)\") flag.Parse() if basePath == \"\" { p, err := build.Default.Import(basePkg, \"\", build.FindOnly) if err != nil { fmt.Fprintf(os.Stderr, \"Couldn't find gopresent files: %v\\n\", err) fmt.Fprintf(os.Stderr, basePathMessage, basePkg) os.Exit(1) } basePath = p.Dir } err := initTemplates(basePath) if err != nil { log.Fatalf(\"Failed to parse templates: %v\", err) } ln, err := net.Listen(\"tcp\", *httpAddr) if err != nil { log.Fatal(err) } defer ln.Close() _, port, err := net.SplitHostPort(ln.Addr().String()) if err != nil { log.Fatal(err) } origin := &url.URL{Scheme: \"http\"} if *originHost != \"\" { origin.Host = net.JoinHostPort(*originHost, port) } else if ln.Addr().(*net.TCPAddr).IP.IsUnspecified() { name, _ := os.Hostname() origin.Host = net.JoinHostPort(name, port) } else { reqHost, reqPort, err := net.SplitHostPort(*httpAddr) if err != nil { log.Fatal(err) } if reqPort == \"0\" { origin.Host = net.JoinHostPort(reqHost, port) } else { origin.Host = *httpAddr } } if present.PlayEnabled { if *nativeClient { socket.RunScripts = false socket.Environ = func() []string { if runtime.GOARCH == \"amd64\" { return environ(\"GOOS=nacl\", \"GOARCH=amd64p32\") } return environ(\"GOOS=nacl\") } } playScript(basePath, \"SocketTransport\") http.Handle(\"/socket\", socket.NewHandler(origin)) } http.Handle(\"/static/\", http.FileServer(http.Dir(basePath))) if !ln.Addr().(*net.TCPAddr).IP.IsLoopback() && present.PlayEnabled && !*nativeClient { log.Print(localhostWarning) } log.Printf(\"Open your web browser and visit %s\", origin.String()) log.Fatal(http.Serve(ln, nil)) } 流行的present命令的main函数，很多Go的用户使用它来制作幻灯片。许多演讲者修改了这个模块来满足自己的需要。 Q&A Q: 在GO语言中，我所怀念的一项功能是一个好的调试器。 A: 我们正在做了，不只是调试器，我们还会提供一个更好的总体监视工具可以让你在程序运行时更好地洞察程序在干什么(显示出所有正在运行的goroutine的状态)。在GO 1.5中探索它吧。 出处 go 语言学习历程 接触go是2012年的时候，真正开始系统的学习和开发系统是2014年了，go语言的学习也算自己2014年的重要工作之一，对go语言学习的总结，也算是年底总结之一 学习go的原因和动机： 先前做过2年Unix c开发经验, 对于C系的语言有特殊的感情，go特别适合我胃口，用过后爱不释手； go语言团队太过耀眼和强大：Thompson 图灵奖获得者，unix 和C的共同发明人；Pike PLAN9操作系统的主要开发者、UTF-8发明者；Robert Griesemer 参与java的HotSpot, js v8引擎开发者； 国内传道者的极力推荐：许式伟兄，谢孟军兄等强力推荐及相关书籍问世； 学习资料： 书籍是：老许的《go语言编程》、 老谢的《go web编程》、 雨痕的《go 语言学习笔记》、 golang.org上面的《Effective Go》、《The Go Programming Language Specification》、go标准库和github上众多开源库 当然无闻的视频教程也是非常适合初学者的，跟着他一起把代码敲一遍事半功倍 go 学习体会： go 语言基础知识非常简单，简单到几天就可以学完，并能够上手开发；但是要做到精通，没有一定的代码量和几年的经验很难达到，这是学习任何一门编程语言都必须要经历的，你唯一能做的是：不停的写代码，不停的思考，不停的总结，不停的读别人代码，向高手请教； go 学习难点: 将我在学习中遇到的难点，以及相关参考资料索引出来，这些知识点对新入门的学习者有点难，但是对于想全面掌握go技能的开发人员来说，我认为是非常有价值的，这些知识点都是个人一步步学习趟过坑之后去发掘的： go map slice string array interface 底层数据模型，其中array 和slice是引起混乱的根源；参见：Russ Cox非常经典文章 Go Data Structures Arrays, slices (and strings): The mechanics of 'append' go defer panic recover 是go特有的，go的错误就是错误，异常就是异常，没有混为一谈，这个设计表面上看代码烦乱了，实际上更清晰；try catch表面上是清晰，实际上隐藏着太多的问题。（两种错误处理机制：异常抛出机制-错误码处理机制） 使用Defer的几个场景 go interface 接口的底层实现机制（能深入到源码）（深入才能理解：接口赋值，接口转换，接口断言及go的动态性）；go就是一门面向接口、面向组合编程的语言，对于go语言来说接口是灵魂一点都不为过； 参见：老许《Go语言编程》 第9章 9.5节 接口机理 参加：国外一位大佬写的：How to use interfaces in Go 参见：interfaces_and_types 参见：Learning Go - Interfaces & Reflections go 类型系统：这个对掌握一个语言非常重要：static type（语言层面就是静态类型语言）, dynamic type（动态类型针对接口而言） ,underly type(底层类型针对强制转换和赋值）；go的类型系统比较简练，干净，都是值类型，即使像slice,map,channel,func 等看起来是引用类型，其实也是值类型，只是其内部数据结构封装了指针罢了；不像JAVA有两套类型：基本的是值类型，对象是引用类型，中间又有装箱，拆箱动作，更有奇葩的string； 参见：The Go Programming Language Specification-type 参见：Learning Go - Types go function :多值返回；带命名的返回参数用法；闭包；函数是一等公民；高阶函数；函数也是一种基础类型，可以type xxx func 为函数新定义一种类型；并发go以h函数为载体；对象是附有行为的数据，而闭包是附有数据的行为 参见国外大牛：Function Types in Go (golang) go闭包：函数编程之闭包漫谈(Closure) Go语言(Golang) - 闭包 go函数式编程：go函数式编程实践 go 参数传递：函数参数全部是传值：即使传递的是指针，传递的也是指针的拷贝；闭包引用外部变量是引用 所谓引用是指使用的不是指针，但是却有指针的效果,引用：a做为参数传递函数内部，函数内部修改a却改变了外部a的值 指针：a作为参数传递到函数内部，函数内部修改了a的值，外部a指向的值也发生改变； 参见：Go语言的传参和传引用 这篇文章分析的非常到位时难得好文章 go error 处理机制,error 与nil 关系，参见Go中error类型的nil值和nil 国外这两篇文章写得也比较好，教你如何自定义error以返回更具体的错误； Error Handling In Go, Part I Error Handling In Go, Part II go nil 也一直是困扰go学习者的一个绊脚石 上面有篇 error nil 相关的文章 这里有陈一回的 Interface nil 的文章 golang: 详解interface和nil 陈兄关于go的几篇文章都非常接地气，建议都看了 go package、全局const(常量）、var（变量）加载顺序，及package引用机制： 参见：老许翻译的那本《Go语言程序设计》 go reflect ：反射是一个强大的武器，是一个新手成为老手的必须涉猎的东西，也是元编程的一种方式，其性能相对来说不太高（灵活性也带来性能问题） 参见：官方版 laws-of-reflection 翻译版的：The-laws-of-reflection 我认为这是翻译的最好的一篇文章，融入了作者的思考和感悟 还有我的简写版的，更多的是个API的指引：The laws of reflection 反射小试身手：参考这篇在 GOLANG 中用名字调用函数 Mikespook翻译的其他文章也非常棒 martini 框架使用的经典DI库：inject 教科书办实现注入 inject库代码非常晦涩，可以参考陈兄的这边经典文章golang: Martini之inject源码分析 这篇文章深入浅出，写的非常好 反射与接口、go类型系统关系非常密切，refelct.TypeOf 返回的是接口的dynamic type , func (v Value) Type() Type返回value的type, reflect.Type表述的是underlying type go channel和gorutone使用方法；并发编程模式；实现原理. 如果形容go语言是一个皇冠，goroutine 和channel则是皇冠上的明珠，go是CSB并发编程理论的实践者和改良派；go将并发编程的复杂性降低了一个数量级，从此并发编程不再是某些自称“技术淫人”的专利；世界本应该如此简单，语言和编译器能做好的事情就不要让程序员瞎忙活，这是go的哲学； 相关参考： 参见《go并发编程》(说实在的，这本书写的没有达到我期望的水准，写的都是基础，语言有点啰嗦，挖的够深，但是拔的不高，所谓拔的不高就是没有系统的介绍并发设计模式） 参见goroutine背后的系统知识 go 内存模型 英文版 中文版 英文需要翻墙，有点晦涩难懂，中文的这一篇写的非常好，融入译者自己的思考，推荐阅读； go语言并发之美 这篇文章写得非常好，对常用的并发模式写的深入浅出，这点《go并发编程》一本很厚的书居然没有这些内容，实在让人失望，有点徒有虚名 Google IO大会上大牛的几篇文章（有墙） Concurrency is not Parallelism 这里有篇翻译的并发不是并行 Go Concurrency Patterns Advanced Go Concurrency Patterns Go Concurrency Patterns: Pipelines and cancellation 这里有篇翻译：Go并发模式：管道和显式取消 go 调度器模型，go内存管理，GC，go 调试与性能分析，跨平台；这些都是高级命题，当程序遇到性能问题时，你可能需要去了解go并发的实现机制，找到问题点，规避或者改进或者找到替代方案；除非你有强烈的好奇心，一般的程序员不会去读整个运行时的实现。 参见雨痕学习笔记 The Go scheduler 这里有篇翻译go调度器 阿里skoo的几篇文章 对调度器过程写的非常生动 《go并发编程》对go调度也做了论述 国外的这篇PPT写的也不错 ，还有一篇 github上有本电子书 写的非常深入，对go的几个关键点实现进行深入剖析，非常好的文章 框架学习： 学习了谢大的beego框架，beego非常容易入门，模块化设计，并且模块非常齐全；谢大人比较热情，QQ群较活跃,，我的两个小系统都是基于beego开发的；小黑的这篇导读对于想看框架源码的人来说是个福音； Martini 只是看了inject那部分，2015年希望有时间细看一下 martini 和 revel。 期待 期待有个牛人能出一本专门介绍 go 如何设计大系统的书，go语言设计模式和面向对象设计模式有很大差别；老许有一篇PPT里面介绍go的面向连接和组合的语言，以七牛系统的规模，应该可以抽象出一套模式出来，有人做吗？并发的相关设计模式，网上有多文章，但是还不是很系统；希望2015有人能站出来做这件事情，我们好站在巨人的肩膀上继续前行。 其实不是为了学习而学习： 我很大一部分时间还是边开发，边了解标准库，边学习；遇到比较大的通用的模块到github上找有无已经实现的，如有借鉴过来吧，如果你认为自己改写的比原作者好，可以pull request. 当然在开发中遇到自己知识的盲点，就需要有股专研的精神，把它搞明白，技术也就自然得到提高，个人薄见，谨慎参考。 "},"blog/goroutine.html":{"url":"blog/goroutine.html","title":"进程、线程和协程","keywords":"","body":"进程、线程和协程 要理解什么是goroutine，我们先来看看进程、线程以及协程它们之间的区别，这能帮助我们更好的理解goroutine。 进程：分配完整独立的地址空间，拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程的切换只发生在内核态，由操作系统调度。 线程：和其它本进程的线程共享地址空间，拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程的切换一般也由操作系统调度(标准线程是的)。 协程：和线程类似，共享堆，不共享栈，协程的切换一般由程序员在代码中显式控制。 进程和线程的切换主要依赖于时间片的控制（关于进程和线程的调度方式，具体可参看这篇文章：进程线程调度方式），而协程的切换则主要依赖于自身，这样的好处是避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任。 goroutine可以看作是协程的go语言实现，从百度百科上看协程的定义：与子例程一样，协程（coroutine）也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。实际上，我们可以把子例程当作是协程的一种特例。一般来说，如果没有显式的让出CPU，就会一直执行当前协程。 浅析goroutine 我们知道goroutine是协程的go语言实现，它是语言原生支持的，相对于一般由库实现协程的方式，goroutine更加强大，它的调度一定程度上是由go运行时（runtime）管理。其好处之一是，当某goroutine发生阻塞时（例如同步IO操作等），会自动出让CPU给其它goroutine。 goroutine的使用非常简单，例如foo是一个函数：go foo() 就一个关键字go搞定了，这里会启动一个goroutine执行foo函数，然后CPU继续执行后面的代码。这里虽然启动了goroutine，但并不意味着它会得到马上调度，关于goroutine的调度我们稍后再探讨。 goroutine是非常轻量级的，它就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈（初始大小为4K，会随着程序的执行自动增长删除）。所以它非常廉价，我们可以很轻松的创建上万个goroutine。 go运行时调度 默认的, 所有goroutine会在一个原生线程里跑，也就是只使用了一个CPU核。在同一个原生线程里，如果当前goroutine不发生阻塞，它是不会让出CPU时间给其他同线程的goroutines的。除了被系统调用阻塞的线程外，Go运行库最多会启动$GOMAXPROCS个线程来运行goroutine。 那么goroutine究竟是如何被调度的呢?我们从go程序启动开始说起。在go程序启动时会首先创建一个特殊的内核线程sysmon，从名字就可以看出来它的职责是负责监控的，goroutine背后的调度可以说就是靠它来搞定。 接下来，我们再看看它的调度模型，go语言当前的实现是N:M。即一定数量的用户线程映射到一定数量的OS线程上，这里的用户线程在go中指的就是goroutine。go语言的调度模型需要弄清楚三个概念：M、P和G，如下图表示： M代表OS线程，G代表goroutine，P的概念比较重要，它表示执行的上下文，其数量由$GOMAXPROCS决定，一般来说正好等于处理器的数量。M必须和P绑定才能执行G，调度器需要保证所有的P都有G执行，以保证并行度。如下图： 从图中我们可以看见，当前有两个P，各自绑定了一个M，并分别执行了一个goroutine，我们还可以看见每个P上还挂了一个G的队列，这个队列是代表私有的任务队列，它们实际上都是runnable状态的goroutine。当使用go关键字声明时,一个goroutine便被加入到运行队列的尾部。一旦一个goroutine运行到一个调度点,上下文便从运行队列中取出一个goroutine, 设置好栈和指令指针,便开始运行新的goroutine。 那么go中切换goroutine的调度点有哪些呢？具体有以下三种情况 调用runtime·gosched函数。goroutine主动放弃CPU，该goroutine会被设置为runnable状态，然后放入一个全局等待队列中，而P将继续执行下一个goroutine。使用runtime·gosched函数是一个主动的行为，一般是在执行长任务时又想其它goroutine得到执行的机会时调用。 调用runtime·park函数。goroutine进入waitting状态，除非对其调用runtime·ready函数，否则该goroutine将永远不会得到执行。而P将继续执行下一个goroutine。使用runtime·park函数一般是在某个条件如果得不到满足就不能继续运行下去时调用，当条件满足后需要使用runtime·ready以唤醒它（这里唤醒之后是否会加入全局等待队列还有待研究）。像channel操作，定时器中，网络poll等都有可能park goroutine。 慢系统调用。这样的系统调用会阻塞等待，为了使该P上挂着的其它G也能得到执行的机会，需要将这些goroutine转到另一个OS线程上去。具体的做法是：首先将该P设置为syscall状态，然后该线程进入系统调用阻塞等待。之前提到过的sysmom线程会定期扫描所有的P，发现一个P处于了syscall的状态，就将M和P分离（实际上只有当 Syscall 执行时间超出某个阈值时，才会将 M 与 P 分离）。RUNTIME会再分配一个M和这个P绑定，从而继续执行队列中的其它G。而当之前阻塞的M从系统调用中返回后，会将该goroutine放入全局等待队列中，自己则sleep去。 该图描述了M和P的分离过程。 调度点的情况说清楚了，但整个模型还并不完整。我们知道当使用go去调用一个函数，会生成一个新的goroutine放入当前P的队列中，那么什么时候生成别的OS线程，各个OS线程又是如何做负载均衡的呢？ 当M从队列中拿到一个可执行的G后，首先会去检查一下，自己的队列中是否还有等待的G，如果还有等待的G，并且也还有空闲的P，此时就会通知runtime分配一个新的M（如果有在睡觉的OS线程，则直接唤醒它，没有的话则生成一个新的OS线程）来分担任务。 如果某个M发现队列为空之后，会首先从全局队列中取一个G来处理。如果全局队列也空了，则会随机从别的P那里直接截取一半的队列过来（偷窃任务），如果发现所有的P都没有可供偷窃的G了，该M就会陷入沉睡。 整个调度模型大致就是这样子了，和所有协程的调度一样，在响应时间上，这种协作式调度是硬伤。很容易导致某个协程长时间无法得到执行。但总体来说，它带来的好处更加让人惊叹。想要了解的更多可以看看我下面列出的一些参考资料，或是直接看它的源码：http://golang.org/src/runtime/proc.c 理解goroutine "},"blog/concurrent-programming.html":{"url":"blog/concurrent-programming.html","title":"并发编程","keywords":"","body":"并发编程 一个Go例程(Goroutines)就是一个和其它Go例程在同一地址空间里但却独立运行的函数，就像是在shell里使用 & 标记启动一个命令。 Goroutine 的并发安全性 无论是 Windows 还是 Linux，基本上来说是用操作系统的线程来实现的，不过，Goroutine不是线程。它有个特性，如果当一个Go例程阻塞时，所在的线程会阻塞，但其它Go例程不受影响，多个例程可以在系统线程上做多路通信。堆栈初始很小，但随着需求会增长或收缩，Go例程不是不耗资源，但它们很轻量级的。 这并不是真正的并发，如果你要真正的并发，你需要在你的 main 函数的第一行加上下面的这段代码： import \"runtime\" ... NCPU := runtime.NumCPU() runtime.GOMAXPROCS(NCPU) 并发(Concurrency)不是并行(Parallelism) --Rob Pike Go语言提供： 并发执行(goroutines) 并发是一种将一个程序分解成小片段独立执行的程序设计方法，通信是指各个独立的执行任务间的合作。 并发将相互独立的执行过程综合到一起的编程技术。(这里是指通常意义上的执行过程，而不是Linux进程。很难定义。) 并行同时执行(通常是相关的)计算任务的编程技术。 并发是指同时处理很多事情，而并行是指同时能完成很多事情，两者不同，但相关，一个重点是组合，一个重点是执行。 并发提供了一种方式让我们能够设计一种方案将问题(非必须的)并行的解决。 同步和消息传输(channels) 多路并发控制(select) 通道 Channels 通道是类型化的值，能够被Go例程用来做同步或交互信息。 timerChan := make(chan time.Time) go func() { time.Sleep(deltaT) timerChan Select 这select语句很像switch，但它的判断条件是基于通信，而不是基于值的等量匹配。 select { case v := 闭包 它让一些并发运算更容易表达： func Compose(f, g func(x float) float) func(x float) float { return func(x float) float { return f(g(x)) } } print(Compose(sin, cos)(0.5)) Demo // 使用闭包封装一个后台操作： go func() { // 从输入通道拷贝数据到输出通道 for val := range input { output 这个负载均衡的例子具有很明显的并行和可扩展性，Worker数可以非常巨大。Go语言的这种并发特征能的开发一个安全的、好用的、可扩展的、并行的软件变得很容易。 并发简化了同步，没有明显的需要同步的操作，程序的这种设计隐含的实现了同步。 Demo(查询数据库) func Query(conns []Conn, query string) Result { ch := make(chan Result, len(conns)) // buffered for _, conn := range conns { go func(c Conn) { ch 并发和垃圾回收机制让这成为一个很小很容易解决的问题。 GO并发编程实战 Go语言并发之美 "},"blog/loadbalancing.html":{"url":"blog/loadbalancing.html","title":"负载均衡","keywords":"","body":"负载均衡 请求者向均衡服务发送请求 type Request struct { fn func() int // The operation to perform. c chan int // The channel to return the result. } 注意这返回的通道是放在请求内部的。通道是first-class值 能很好的模拟一个请求者，一个负载产生者 func requester(work chan请求通道，加上一些负载记录数据 type Worker struct { requests chan Request // work to do (buffered channel) pending int // count of pending tasks index int // index in the heap } 均衡服务将请求发送给压力最小的worker func (w *Worker) work(done chan *Worker) { for { req := 请求通道(w.requests)将请求提交给各个worker。均衡服务跟踪请求待处理的数量来判断负载情况。 每个响应直接反馈给它的请求者。 定义负载均衡器// 负载均衡器需要一个装很多worker的池子和一个通道来让请求者报告任务完成情况。 type Pool []*Worker type Balancer struct { pool Pool done chan *Worker } 负载均衡函数func (b *Balancer) balance(work chan Request) { for { select { case req := 将负载均衡的池子用一个Heap接口实现// 使用堆来跟踪负载情况 func (p Pool) Less(i, j int) bool { return p[i].pending Dispatch// Send Request to worker func (b *Balancer) dispatch(req Request) { // Grab the least loaded worker... w := heap.Pop(&b.pool).(*Worker) // ...send it the task. w.requests Completed// Job is complete; update heap func (b *Balancer) completed(w *Worker) { // One fewer in the queue. w.pending-- // Remove it from heap. heap.Remove(&b.pool, w.index) // Put it into its place on the heap. heap.Push(&b.pool, w) } 一个复杂的问题可以被拆分成容易理解的组件。它们可以被并发的处理。结果就是容易理解，高效，可扩展，好用。或许更加并行。 "}}
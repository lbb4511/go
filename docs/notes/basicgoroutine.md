# 通道

通道（Channel）是 Go 语言中一种非常独特的数据结构。它可用于在不同 Goroutine 之间传递类型化的数据，并且是并发安全的。相比之下，我们之前介绍的那些数据类型都不是并发安全的。这一点需要特别注意。

Goroutine（也称为 Go 程序）可以被看做是承载可被并发执行的代码块的载体。它们由 Go 语言的运行时系统调度，并依托操作系统线程（又称内核线程）来并发地执行其中的代码块。至于怎样编写这样的代码块以及怎样驱动这样的代码块执行，我们先按下不表。通道类型的表示方法很简单，仅由两部分组成，如下：

```go
chan T
```

在这个类型字面量中，左边是代表通道类型的关键字 chan，而右边则是一个可变的部分，即代表该通道类型允许传递的数据的类型（或称通道的元素类型）。这两部分之间需要以空格分隔。

与其它的数据类型不同，我们无法表示一个通道类型的值。因此，我们也无法用字面量来为通道类型的变量赋值。我们只能通过调用内建函数 make 来达到目的。make 函数可接受两个参数。第一个参数是代表了将被初始化的值的类型的字面量（比如 chan int），而第二个参数则是值的长度。例如，若我们想要初始化一个长度为 5 且元素类型为 int 的通道值，则需要这样写：

```go
make(chan int, 5)
```

> 实际上 make 函数也可以被用来初始化切片类型或字典类型的值。
> 确切地说，通道值的长度应该被称为其缓存的尺寸。换句话说，它代表着通道值中可以暂存的数据的个数。注意，暂存在通道值中的数据是先进先出的，即：越早被放入（或称发送）到通道值的数据会越先被取出（或称接收）。

这实际上只是 Go 语言中的通道的一种。它被称为带缓冲的通道，或简称为缓冲通道。

通道有带缓冲和非缓冲之分。我们已经说过，缓冲通道中可以缓存 N 个数据。我们在初始化一个通道值的时候必须指定这个 N。相对的，非缓冲通道不会缓存任何数据。发送方在向通道值发送数据的时候会立即被阻塞，直到有某一个接收方已从该通道值中接收了这条数据。非缓冲的通道值的初始化方法如下：

```go
make(chan int, 0)
```

注意，在这里，给予 make 函数的第二个参数值是 0。

除了上述分类方法，我们还可以以数据在通道中的传输方向为依据来划分通道。默认情况下，通道都是双向的，即双向通道。如果数据只能在通道中单向传输，那么该通道就被称作单向通道。我们在初始化一个通道值的时候不能指定它为单向。但是，在编写类型声明的时候，我们却是可以这样做的。例如：

```go
type Receiver <-chan int
type Sender chan<- int
```

类型 Receiver 代表了一个只可从中接收数据的单向通道类型。这样的通道也被称为接收通道。在关键字 chan 左边的接收操作符<-形象地表示出了数据的流向。相对应的，Sender 是一个发送通道类型。<-被放在了 chan 的右边，并且“箭头”直指“通道”。想必不用多说你也能明白了。我们可以把一个双向通道值赋予上述类型的变量，就像这样：

```go
var myChannel = make(chan int, 3)
var sender Sender = myChannel
var receiver Receiver = myChannel
```

但是，反之则是不行的。像下面这样的代码是通不过编译的：`var myChannel1 chan int = sender`单向通道的主要作用是约束程序对通道值的使用方式。比如，我们调用一个函数时给予它一个发送通道作为参数，以此来约束它只能向该通道发送数据。又比如，一个函数将一个接收通道作为结果返回，以此来约束调用该函数的代码只能从这个通道中接收数据。这属于 API 设计的范畴。因此我们在这里仅了解一下即可。

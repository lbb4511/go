# 数组和切片

## 数组

一个数组（Array）就是一个可以容纳若干类型相同的元素的容器。这个容器的大小（即数组的长度）是固定的，且是体现在数组的类型字面量之中的。比如，我们声明了一个数组类型：

```go
type MyNumbers [3]int
```

## 切片

切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。与数组不同的是，无法通过切片类型来确定其值的长度。每个切片值都会将数组作为其底层数据结构。我们也把这样的数组称为切片的底层数组。 表示切片类型的字面量如：

```go
[]int
[]string
```

我们已经知道，在进行“切片”操作的时候需要指定元素下界索引和元素上界索引，就像这样：
`numbers3[1:4]`
在有些时候，我们还可以在方括号中放入第三个正整数，如下所示：
`numbers3[1:4:4]`
这第三个正整数被称为容量上界索引。它的意义在于可以把作为结果的切片值的容量设置得更小。换句话说，它可以限制我们通过这个切片值对其底层数组中的更多元素的访问。下面举个例子。让我们先来回顾下在上一节讲到的 numbers3 和 slice1。针对它们的赋值语句是这样的：

```go
var numbers3 = [5]int{1, 2, 3, 4, 5}
var slice1 = numbers3[1:4]
```

这时，变量 slice1 的值是[]int{2, 3, 4}。但是我们可以通过如下操作将其长度延展得与其容量相同：

```go
slice1 = slice1[:cap(slice1)]
```

通过此操作，变量 slice1 的值变为了[]int{2, 3, 4, 5}，且其长度和容量均为 4。现在，numbers3 的值中的索引值在[1,5)范围内的元素都被体现在了 slice1 的值中。这是以 numbers3 的值是 slice1 的值的底层数组为前提的。这意味着，我们可以轻而易举地通过切片值访问其底层数组中对应索引值更大的更多元素。如果我们编写的函数返回了这样一个切片值，那么得到它的程序很可能会通过这种技巧访问到本不应该暴露给它的元素。这是确确实实是一个安全隐患。

如果我们在切片表达式中加入了第三个索引（即容量上界索引），如：

```go
var slice1 = numbers3[1:4:4]
```

那么在这之后，无论我们怎样做都无法通过 slice1 访问到 numbers3 的值中的第五个元素。因为这超出了我们刚刚设定的 slice1 的容量。如果我们指定的元素上界索引或容量上界索引超出了被操作对象的容量，那么就会引发一个运行时恐慌（程序异常的一种），而不会有求值结果返回。因此，这是一个有力的访问控制手段。

虽然切片值在上述方面受到了其容量的限制，但是我们却可以通过另外一种手段对其进行不受任何限制地扩展。这需要使用到内建函数 append。append 会对切片值进行扩展并返回一个新的切片值。使用方法如下：

```go
slice1 = append(slice1, 6, 7)
```

通过上述操作，slice1 的值变为了[]int{2, 3, 4, 6, 7}。注意，一旦扩展操作超出了被操作的切片值的容量，那么该切片的底层数组就会被自动更换。这也使得通过设定容量上界索引来对其底层数组进行访问控制的方法更加严谨了。

> 我们要介绍的最后一种操作切片值的方法是“复制”。该操作的实施方法是调用 copy 函数。该函数接受两个类型相同的切片值作为参数，并会把第二个参数值中的元素复制到第一个参数值中的相应位置（索引值相同）上。这里有两点需要注意：

1. 这种复制遵循最小复制原则，即：被复制的元素的个数总是等于长度较短的那个参数值的长度。
2. 与 append 函数不同，copy 函数会直接对其第一个参数值进行修改。
   举例如下：

   ```go
   var slice4 = []int{0, 0, 0, 0, 0, 0, 0}
   copy(slice4, slice1)
   ```

   通过上述复制操作，slice4 会变为[]int{2, 3, 4, 6, 7, 0, 0}。

## 字典类型

Go 语言的字典（Map）类型其实是哈希表（Hash Table）的一个实现。字典用于存储键-元素对（更通俗的说法是键-值对）的无序集合。注意，同一个字典中的每个键都是唯一的。如果我们在向字典中放入一个键值对的时候其中已经有相同的键的话，那么与此键关联的那个值会被新值替换。字典类型的字面量如下：

```go
map[K]T
```
